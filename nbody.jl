"""
    N-Body Galaxy Simulation in Julia
    =================================

This script simulates the gravitational dynamics of galaxies using an N-body approach.
It implements an all-pairs gravity calculation with Plummer softening for numerical stability.

Key Features:
- Multiple simulation scenarios: spiral galaxy collision, simple galaxy collision, 
  Plummer sphere, and random particle distribution
- Leapfrog integration scheme for accurate orbital dynamics
- Real-time visualization with particle trails and energy conservation plots
- Optimized Julia implementation with broadcasting and in-place operations
- Symmetric force calculation to ensure momentum conservation
- Import initial conditions from JSON files for reproducible results across languages

Physics:
- Gravitational force between all particle pairs (O(N²) complexity)
- Plummer softening to prevent infinite forces at close encounters
- Leapfrog integration: kick-drift-kick scheme for energy conservation
- Center-of-mass frame to eliminate overall system drift

Author: Bart Blockmans
Date: August 2025

Usage:
- Set IMPORT_IC = nothing to generate initial conditions using the current method
- Set IMPORT_IC = "filename.json" to import initial conditions from a JSON file
  (e.g., "nbody_ic_galaxy_spiral_N4000.json" generated by nbody_ic.py)
"""

# =============================================================================
# CONFIGURATION SECTION
# =============================================================================

# Visualization and Output Settings
const VISUALIZE = false          # Enable real-time plotting (set to false for headless runs)
const STOREFINAL = true          # Save initial & final PNGs to ./julia/ directory (works also if VISUALIZE=false)
const STOREALL = true            # Save all snapshots to ./julia/ directory

# Simulation Parameters
const USE_SYM   = true             # Use symmetric i<j force loop for equal/opposite force updates
const SCENARIO  = "galaxy_spiral"  # Simulation scenario: "galaxy_spiral" | "galaxy" | "plummer" | "random"
const N         = 4000             # Number of particles
const tEnd      = Float32(3.0)     # Total simulation time
const dt        = Float32(1e-3)    # Time step (small step maintains galaxy stability)
const Gconst    = Float32(1.0)     # Gravitational constant (normalized units)
const softening = Float32(1.5e-2)  # Plummer softening parameter (prevents infinite forces)
const SEED      = 17               # Random seed for reproducible results

# Initial Conditions Import
# Set to filename (e.g., "nbody_ic_galaxy_spiral_N4000.json") to import initial conditions
# Set to nothing to generate initial conditions using the current method
const IMPORT_IC = "nbody_ic_galaxy_spiral_N4000.json"

# Visualization Parameters (only used when VISUALIZE=true or STOREFINAL=true)
const TRAIL      = 80               # Number of time steps to show particle trails (works for 0, 1, or >1)
const POINT_SIZE = 5.0              # Size of current-position markers
const CMAP       = :viridis         # Color map for speed-based particle coloring
const DEPTH_CUE  = true             # Enable depth cueing (size based on z-coordinate)
const BOUNDS     = 3.5f0            # Plot boundaries: x,y limits = ±BOUNDS
const OUTPUT_STEP = 300             # Frequency of output visualization
FIGURE_NUM = 1                      # Sequential figure counter (separate from iteration number)

# =============================================================================
# IMPORTS AND DEPENDENCIES
# =============================================================================

using Random, Statistics
using CairoMakie
using Distributions: Gamma
using JSON3  # For parsing initial conditions JSON files

# =============================================================================
# INITIAL CONDITIONS IMPORT FUNCTION
# =============================================================================

"""
    import_initial_conditions(filename)

Import initial conditions from a JSON file generated by nbody_ic.py.

# Arguments
- `filename`: Path to the JSON file containing initial conditions

# Returns
- `x, y, z, u, v, w, m`: Particle positions, velocities, and masses
- `G_actual, softening_actual`: Gravitational constant and softening parameter from the file

# Throws
- `ArgumentError`: If the specified file doesn't exist
- `ErrorException`: If the file format is invalid or incompatible
"""
function import_initial_conditions(filename::String)
    # Check if file exists
    if !isfile(filename)
        throw(ArgumentError("Initial conditions file not found: $filename"))
    end
    
    try
        # Read and parse JSON file
        data = JSON3.read(filename)
        
        # Validate file format
        if !haskey(data, :format_version)
            throw(ErrorException("Invalid file format: missing 'format_version'"))
        end
        
        if !haskey(data, :metadata) || !haskey(data, :particles)
            throw(ErrorException("Invalid file format: missing 'metadata' or 'particles' sections"))
        end
        
        # Extract metadata
        metadata = data.metadata
        scenario = get(metadata, :scenario, "unknown")
        file_N = get(metadata, :N, 0)
        file_G = get(metadata, :Gconst, 1.0)
        file_softening = get(metadata, :softening, 0.015)
        file_seed = get(metadata, :seed, 0)
        
        # Extract particle data
        particles = data.particles
        x = Float32.(particles.positions.x)
        y = Float32.(particles.positions.y)
        z = Float32.(particles.positions.z)
        u = Float32.(particles.velocities.u)
        v = Float32.(particles.velocities.v)
        w = Float32.(particles.velocities.w)
        m = Float32.(particles.masses)
        
        # Validate data consistency
        if length(x) != file_N
            throw(ErrorException("Particle count mismatch: expected $file_N, got $(length(x))"))
        end
        
        if length(x) != length(y) || length(x) != length(z) || 
           length(x) != length(u) || length(x) != length(v) || 
           length(x) != length(w) || length(x) != length(m)
            throw(ErrorException("Inconsistent array lengths in particle data"))
        end
        
        # Print import information
        println("Imported initial conditions from: $filename")
        println("  Scenario: $scenario")
        println("  Particles: $file_N")
        println("  G: $(file_G)")
        println("  Softening: $(file_softening)")
        println("  Seed: $file_seed")
        println("  Generated by: $(get(metadata, :generated_by, "unknown"))")
        println("  Timestamp: $(get(metadata, :timestamp, "unknown"))")
        
        # Return values
        G_actual = Float32(file_G)
        softening_actual = Float32(file_softening)
        
        return x, y, z, u, v, w, m, G_actual, softening_actual
        
    catch e
        if e isa ArgumentError
            rethrow(e)
        else
            throw(ErrorException("Error reading initial conditions file: $(e)"))
        end
    end
end

# =============================================================================
# CORE PHYSICS FUNCTIONS
# =============================================================================

"""
    compute_acc!(ax, ay, az, x, y, z, m, G, eps, use_sym)

Compute gravitational acceleration for all particles in-place.

This is the computationally intensive O(N²) part of the simulation.
Uses Plummer softening to prevent infinite forces at close encounters.
The function modifies the acceleration arrays in-place for efficiency.

# Arguments
- `ax, ay, az`: Acceleration component vectors (modified in-place)
- `x, y, z`: Particle position vectors
- `m`: Particle mass vector
- `G`: Gravitational constant
- `eps`: Softening parameter (Plummer radius)
- `use_sym`: If true, use symmetric i<j loop for equal/opposite forces

# Algorithm
- If `use_sym=true`: Compute force between each pair only once (more efficient)
- If `use_sym=false`: Compute all N² forces explicitly (slower but more explicit)
- Uses `@inbounds` for performance optimization
- Applies Plummer softening: r² → r² + ε² to prevent infinite forces
"""
function compute_acc!(ax::Vector{Float32}, ay::Vector{Float32}, az::Vector{Float32},
                      x::Vector{Float32}, y::Vector{Float32}, z::Vector{Float32},
                      m::Vector{Float32}, G::Float32, eps::Float32, use_sym::Bool)
    @inbounds begin
        # Initialize acceleration arrays to zero
        fill!(ax, 0f0); fill!(ay, 0f0); fill!(az, 0f0)
        N = length(x)
        eps2 = eps*eps  # Softening parameter squared
        
        if use_sym
            # Symmetric loop: compute force between each pair only once
            # This is more efficient and ensures exact momentum conservation
            for i in 1:N-1
                xi = x[i]; yi = y[i]; zi = z[i]; mi = m[i]  # Position and mass of particle i
                
                for j in i+1:N
                    # Vector from particle i to particle j
                    dx = x[j] - xi
                    dy = y[j] - yi
                    dz = z[j] - zi
                    
                    # Distance squared with softening (prevents infinite forces)
                    r2 = dx*dx + dy*dy + dz*dz + eps2
                    
                    # Compute 1/r and 1/r³ for force calculation
                    invr  = inv(sqrt(r2))       # 1/r
                    invr3 = invr / r2           # 1/r³
                    
                    # Force magnitude (scalar)
                    s = G * invr3
                    
                    # Force vector components
                    fx = s * dx; fy = s * dy; fz = s * dz
                    
                    # Apply equal and opposite forces (Newton's 3rd law)
                    # Particle i feels force from particle j
                    ax[i] += m[j] * fx; ay[i] += m[j] * fy; az[i] += m[j] * fz
                    # Particle j feels equal and opposite force from particle i
                    ax[j] -= mi   * fx; ay[j] -= mi   * fy; az[j] -= mi   * fz
                end
            end
        else
            # Non-symmetric loop: compute all N² forces explicitly
            # This is slower but more straightforward to understand
            for i in 1:N
                xi = x[i]; yi = y[i]; zi = z[i]
                aix = 0f0; aiy = 0f0; aiz = 0f0  # Accumulate accelerations for particle i
                
                for j in 1:N
                    j == i && continue  # Skip self-interaction
                    
                    # Vector from particle i to particle j
                    dx = x[j] - xi
                    dy = y[j] - yi
                    dz = z[j] - zi
                    
                    # Distance squared with softening
                    r2 = dx*dx + dy*dy + dz*dz + eps2
                    invr  = inv(sqrt(r2))
                    invr3 = invr / r2
                    
                    # Force on particle i due to particle j
                    s = G * m[j] * invr3
                    aix += s * dx; aiy += s * dy; aiz += s * dz
                end
                
                # Store accumulated accelerations
                ax[i] = aix; ay[i] = aiy; az[i] = aiz
            end
        end
    end
    return nothing
end

"""
    kinetic_energy(m, u, v, w)

Compute total kinetic energy of the system.

KE = Σ(½ × m × v²) for all particles

# Arguments
- `m`: Particle mass vector
- `u, v, w`: Particle velocity component vectors

# Returns
- Total kinetic energy as Float64
"""
kinetic_energy(m,u,v,w) = begin
    ke = 0.0
    @inbounds for i in eachindex(m)
        # Velocity squared for particle i
        s = float(u[i])*float(u[i]) + float(v[i])*float(v[i]) + float(w[i])*float(w[i])
        ke += 0.5 * float(m[i]) * s
    end
    ke
end

"""
    potential_energy(x, y, z, m, G, eps)

Compute total gravitational potential energy of the system.

PE = -G × Σ(mᵢ × mⱼ / rᵢⱼ) for all particle pairs

# Arguments
- `x, y, z`: Particle position vectors
- `m`: Particle mass vector
- `G`: Gravitational constant
- `eps`: Softening parameter

# Returns
- Total potential energy as Float64
"""
function potential_energy(x,y,z,m,G::Float32,eps::Float32)
    N = length(x); pe = 0.0
    eps2 = float(eps*eps)
    
    # Sum over all particle pairs (i < j to avoid double counting)
    @inbounds for i in 1:N-1
        xi=float(x[i]); yi=float(y[i]); zi=float(z[i]); mi=float(m[i])
        
        for j in i+1:N
            # Distance between particles i and j
            dx=float(x[j])-xi; dy=float(y[j])-yi; dz=float(z[j])-zi
            r = sqrt(dx*dx + dy*dy + dz*dz + eps2)
            
            # Gravitational potential energy between this pair
            pe += -float(G)*mi*float(m[j]) / r
        end
    end
    pe
end

# =============================================================================
# INITIAL CONDITION GENERATORS
# =============================================================================

"""
    disk(N, mass_total; Rmax=1.2f0, z_thick=0.1f0, v_rot=0.9f0, jitter=0.05f0, rng=nothing)

Generate initial conditions for a rotating stellar disk.

Creates a 2D disk with small thickness in the z-direction.
Particles are distributed with circular velocities for orbital stability.

# Arguments
- `N`: Number of particles
- `mass_total`: Total mass of the disk
- `Rmax`: Maximum radius of the disk
- `z_thick`: Thickness of the disk in z-direction
- `v_rot`: Rotation velocity scaling factor
- `jitter`: Random velocity perturbation magnitude
- `rng`: Random number generator

# Returns
- `x, y, z, u, v, w, m`: Particle positions, velocities, and masses
"""
function disk(N::Int, mass_total; Rmax=1.2f0, z_thick=0.1f0, v_rot=0.9f0, jitter=0.05f0, rng=nothing)
    # Use seeded RNG if none provided
    if rng === nothing
        rng = MersenneTwister(SEED)
    end
    
    # Generate radial positions (more particles near center)
    R = Rmax .* sqrt.(rand(rng, Float32, N))
    
    # Generate random azimuthal angles
    θ = 2f0*Float32(pi) .* rand(rng, Float32, N)
    
    # Convert to Cartesian coordinates
    x = R .* cos.(θ);  y = R .* sin.(θ);  z = (z_thick*0.5f0) .* randn(rng, Float32, N)
    
    # Circular velocity for orbital stability
    # v = v_rot × R / (0.3 + R) gives a realistic rotation curve
    vtan = v_rot .* R ./ (0.3f0 .+ R)
    u = -vtan .* sin.(θ);  v = vtan .* cos.(θ);  w = zeros(Float32, N)
    
    # Add random velocity perturbations for realistic dynamics
    u .+= jitter .* randn(rng, Float32, N)
    v .+= jitter .* randn(rng, Float32, N)
    w .+= 0.5f0*jitter .* randn(rng, Float32, N)
    
    # Equal mass particles
    m = fill(Float32(mass_total/N), N)
    return x,y,z,u,v,w,m
end

"""
    spiral_disk(N, mass_total; Rd=0.6f0, Rmax=1.8f0, m=2, pitch_deg=18f0, arm_amp=0.65f0, z_thick=0.08f0, v0=1.0f0, v_rise=0.35f0, nudge_r=0.05f0, nudge_t=0.02f0, jitter=0.03f0, rng=Random.default_rng(), φ0=nothing)

Generate initial conditions for a spiral galaxy disk.

Creates an exponential disk with logarithmic spiral arm overdensities.
This produces more realistic galaxy morphologies than simple disks.

# Arguments
- `N`: Number of particles
- `mass_total`: Total mass of the disk
- `Rd`: Disk scale length (exponential falloff)
- `Rmax`: Maximum disk radius
- `m`: Number of spiral arms
- `pitch_deg`: Pitch angle of spiral arms in degrees
- `arm_amp`: Amplitude of spiral arm overdensity
- `z_thick`: Disk thickness
- `v0`: Circular velocity at large radius
- `v_rise`: Radius where velocity reaches v0
- `nudge_r, nudge_t`: Radial and tangential velocity perturbations for spiral structure
- `jitter`: Random velocity perturbation
- `rng`: Random number generator
- `φ0`: Initial phase angle for spiral arms

# Returns
- `x, y, z, u, v, w, m`: Particle positions, velocities, and masses
"""
function spiral_disk(N::Int, mass_total; Rd=0.6f0, Rmax=1.8f0, m=2, pitch_deg=18f0,
                     arm_amp=0.65f0, z_thick=0.08f0, v0=1.0f0, v_rise=0.35f0,
                     nudge_r=0.05f0, nudge_t=0.02f0, jitter=0.03f0,
                     rng=nothing, φ0::Union{Nothing,Float32}=nothing)
    # Use seeded RNG if none provided
    if rng === nothing
        rng = MersenneTwister(SEED)
    end
    
    # Set initial phase if not provided
    φ0 === nothing && (φ0 = rand(rng, Float32) * 2f0*pi)

    # Generate radial positions using gamma distribution (more realistic than uniform)
    # Gamma(k=2, θ=Rd) truncated at Rmax
    R = rand(rng, Gamma(2.0, Rd), N) .|> Float32
    
    # Ensure all particles are within Rmax
    while true
        mask = R .> Rmax
        any(mask) || break
        R[mask] .= rand(rng, Gamma(2.0, Rd), count(mask)) .|> Float32
    end

    # Spiral arm parameters
    k = 1f0 / tan(deg2rad(pitch_deg))  # Spiral pitch parameter
    
    # Generate azimuthal angles with spiral arm overdensity
    θ = similar(R)
    filled = 0
    
    # Use rejection sampling to create spiral arm structure
    @inbounds while filled < N
        need = N - filled
        th_try = rand(rng, Float32, need*2) .* (2f0*pi)
        Rrep   = repeat(view(R, filled+1:filled+need), inner=2)
        
        # Probability density for spiral arms
        p = 1 .+ arm_amp .* cos.(Float32(m) .* (th_try .- k .* log.(Rrep .+ 1f-6) .- φ0))
        uacc = rand(rng, Float32, length(th_try)) .* (1 + arm_amp)
        
        # Accept particles based on spiral arm probability
        keep = uacc .< p
        nkeep = min(need, count(keep))
        θ[filled+1:filled+nkeep] .= view(th_try, findall(keep))[1:nkeep]
        filled += nkeep
    end

    # Convert to Cartesian coordinates
    x = R .* cos.(θ);  y = R .* sin.(θ);  z = (z_thick*0.5f0) .* randn(rng, Float32, N)
    
    # Velocity field with spiral structure
    v_circ = v0 .* tanh.(R ./ v_rise)  # Circular velocity
    phase = Float32(m) .* (θ .- k .* log.(R .+ 1f-6) .- φ0)  # Spiral phase
    
    # Velocity perturbations aligned with spiral arms
    v_r = nudge_r .* v_circ .* cos.(phase)  # Radial velocity
    v_t = v_circ .* (1 .+ nudge_t .* sin.(phase))  # Tangential velocity

    # Convert to Cartesian velocity components
    u = -v_t .* sin.(θ) .+ v_r .* cos.(θ)
    v =  v_t .* cos.(θ) .+ v_r .* sin.(θ)
    w =  0.5f0*jitter .* randn(rng, Float32, N)
    
    # Add random perturbations
    u .+= jitter .* randn(rng, Float32, N)
    v .+= jitter .* randn(rng, Float32, N)
    
    # Equal mass particles
    m = fill(Float32(mass_total/N), N)
    return x,y,z,u,v,w,m
end

"""
    init_ic(N, seed, scenario)

Generate initial conditions for the N-body simulation.

Creates different particle distributions based on the selected scenario.
All scenarios are set up in the center-of-mass frame for numerical stability.

# Arguments
- `N`: Number of particles
- `seed`: Random seed for reproducible results
- `scenario`: Initial condition type: "galaxy_spiral", "galaxy", "plummer", or "random"

# Returns
- `x, y, z, u, v, w, m`: Initial particle positions, velocities, and masses
"""
function init_ic(N::Int, seed::Int, scenario::AbstractString)
    rng = MersenneTwister(seed)

    if scenario == "galaxy_spiral"
        # Two spiral galaxies on collision course
        N1 = N ÷ 2; N2 = N - N1
        
        # Different initial phases for the two galaxies
        φ1 = rand(rng, Float32) * 2f0*pi
        φ2 = φ1 + Float32(pi)/3f0

        # Generate first spiral galaxy
        x1,y1,z1,u1,v1,w1,m1 = spiral_disk(N1, 10f0; Rd=0.55f0, Rmax=1.7f0, m=2,
            pitch_deg=18f0, arm_amp=0.70f0, z_thick=0.07f0, v0=1.05f0, v_rise=0.32f0,
            nudge_r=0.06f0, nudge_t=0.03f0, jitter=0.025f0, rng=rng, φ0=φ1)
        
        # Generate second spiral galaxy
        x2,y2,z2,u2,v2,w2,m2 = spiral_disk(N2, 10f0; Rd=0.55f0, Rmax=1.7f0, m=2,
            pitch_deg=18f0, arm_amp=0.70f0, z_thick=0.07f0, v0=1.05f0, v_rise=0.32f0,
            nudge_r=0.06f0, nudge_t=0.03f0, jitter=0.025f0, rng=rng, φ0=φ2)

        # Reverse velocity of second galaxy and offset positions
        u2 .*= -1; v2 .*= -1  # Counter-rotating
        d = 2.1f0; vcm = 0.45f0  # Initial separation and center-of-mass velocity
        
        # Position and velocity offsets for collision
        x1 .+= -d; v1 .+=  vcm
        x2 .+=  d; v2 .+= -vcm

        # Combine the two galaxies
        x = vcat(x1,x2); y = vcat(y1,y2); z = vcat(z1,z2)
        u = vcat(u1,u2); v = vcat(v1,v2); w = vcat(w1,w2)
        m = vcat(m1,m2)

    elseif scenario == "galaxy"
        # Two simple disk galaxies on collision course
        N1 = N ÷ 2; N2 = N - N1
        
        # Generate two identical disk galaxies
        x1,y1,z1,u1,v1,w1,m1 = disk(N1, 10f0; Rmax=1.1f0, z_thick=0.08f0, v_rot=1.0f0, jitter=0.05f0, rng=rng)
        x2,y2,z2,u2,v2,w2,m2 = disk(N2, 10f0; Rmax=1.1f0, z_thick=0.08f0, v_rot=1.0f0, jitter=0.05f0, rng=rng)
        
        # Counter-rotating galaxies
        u2 .*= -1; v2 .*= -1
        d=2.0f0; vcm=0.5f0  # Initial separation and center-of-mass velocity
        
        # Position and velocity offsets
        x1 .+= -d; v1 .+=  vcm
        x2 .+=  d; v2 .+= -vcm
        
        # Combine the galaxies
        x = vcat(x1,x2); y = vcat(y1,y2); z = vcat(z1,z2)
        u = vcat(u1,u2); v = vcat(v1,v2); w = vcat(w1,w2)
        m = vcat(m1,m2)

    elseif scenario == "plummer"
        # Plummer sphere: a realistic model for globular clusters
        a = 0.5f0  # Scale radius
        
        # Generate positions using Plummer distribution
        uU = rand(rng, Float32, N)
        r  = a ./ sqrt.(uU.^(-2f0/3f0) .- 1f0 .+ 1f-6)  # Radial distribution
        
        # Random spherical angles
        ϕ   = 2f0*pi .* rand(rng, Float32, N)      # Azimuthal
        cosθ = 2f0 .* rand(rng, Float32, N) .- 1f0  # Cosine of polar
        sinθ = sqrt.(1f0 .- cosθ.^2)                # Sine of polar
        
        # Convert to Cartesian coordinates
        x = r .* sinθ .* cos.(ϕ); y = r .* sinθ .* sin.(ϕ); z = r .* cosθ
        
        # Small random velocities
        u = 0.02f0 .* randn(rng, Float32, N)
        v = 0.02f0 .* randn(rng, Float32, N)
        w = 0.02f0 .* randn(rng, Float32, N)
        m = fill(20f0/N, N)

    else # "random"
        # Random particle distribution (useful for testing)
        x = randn(rng, Float32, N); y = randn(rng, Float32, N); z = randn(rng, Float32, N)
        u = randn(rng, Float32, N); v = randn(rng, Float32, N); w = randn(rng, Float32, N)
        m = fill(20f0/N, N)
    end

    # Transform to center-of-mass frame for numerical stability
    # This prevents the entire system from drifting
    μu = mean(m .* u); μv = mean(m .* v); μw = mean(m .* w); m̄ = mean(m)
    u .-= μu/m̄; v .-= μv/m̄; w .-= μw/m̄

    return x,y,z,u,v,w,m
end

# =============================================================================
# VISUALIZATION FUNCTIONS
# =============================================================================

"""
    render_snapshot(path::AbstractString, x::AbstractVector{<:Real}, y::AbstractVector{<:Real},
                    z::AbstractVector{<:Real}, u::AbstractVector{<:Real},
                    v::AbstractVector{<:Real}, w::AbstractVector{<:Real},
                    title_str::AbstractString, times::Union{Nothing,AbstractVector{<:Real}}=nothing,
                    KE_save::Union{Nothing,AbstractVector{<:Real}}=nothing,
                    PE_save::Union{Nothing,AbstractVector{<:Real}}=nothing)

Save a snapshot matching the live visualization layout.

Creates a standalone figure with the same layout as the live visualization:
- Top panel: Particle positions with dark theme
- Bottom panel: Energy evolution with light theme (when energy data provided)

# Arguments
- `path`: File path for saving the image
- `x, y, z, u, v, w`: Particle positions and velocities
- `title_str`: Title for the plot
- `times`: Time points for energy history (optional)
- `KE_save`: Kinetic energy history (optional)
- `PE_save`: Potential energy history (optional)
"""
function render_snapshot(path::AbstractString,
                         x::AbstractVector{<:Real}, y::AbstractVector{<:Real},
                         z::AbstractVector{<:Real}, u::AbstractVector{<:Real},
                         v::AbstractVector{<:Real}, w::AbstractVector{<:Real},
                         title_str::AbstractString, times::Union{Nothing,AbstractVector{<:Real}}=nothing,
                         KE_save::Union{Nothing,AbstractVector{<:Real}}=nothing,
                         PE_save::Union{Nothing,AbstractVector{<:Real}}=nothing)
    
    if times !== nothing && KE_save !== nothing && PE_save !== nothing
        # Two-panel layout matching live visualization
        fig = Figure(size = (680, 820))
        grid = fig[1,1] = GridLayout()
        
        # Upper 2 panels merged for positions (dark theme)
        ax_pos = Axis(grid[1:2,1];
            backgroundcolor = :black,
            xticklabelcolor = :white, yticklabelcolor = :white,
            xlabelcolor = :white, ylabelcolor = :white,
            titlecolor = :white, xtickcolor=:white, ytickcolor=:white)
        
        # Color particles by speed
        speed = sqrt.((u.^2) .+ (v.^2) .+ (w.^2))
        smin = quantile(speed, 0.05); smax = max(quantile(speed, 0.95), smin + 1f-6)

        # Apply depth cueing if enabled
        sizes = fill(POINT_SIZE, length(x))
        if DEPTH_CUE
            zmin = quantile(z, 0.05); zmax = quantile(z, 0.95); zrange = max(zmax - zmin, 1f-3)
            depth = clamp.((z .- zmin) ./ zrange, 0f0, 1f0)
            sizes = POINT_SIZE .* (0.6 .+ 0.8 .* (1f0 .- depth))  # Nearer = bigger
        end

        # Plot particles
        scatter!(ax_pos, x, y; color=speed, colormap=CMAP, colorrange=(smin,smax),
                 markersize=sizes, transparency=true)
        xlims!(ax_pos, -BOUNDS, BOUNDS); ylims!(ax_pos, -BOUNDS, BOUNDS)
        ax_pos.aspect = DataAspect()
        ax_pos.title = title_str
        
        # Bottom panel for energies (light theme)
        ax_eng = Axis(grid[3,1])
        
        # Plot energy evolution
        lines!(ax_eng, times, KE_save; color = (0.98, 0.42, 0.42), linewidth = 1.2, label="KE")
        lines!(ax_eng, times, PE_save; color = (0.30, 0.64, 1.00), linewidth = 1.2, label="PE")
        lines!(ax_eng, times, (KE_save .+ PE_save); color = (0.15, 0.15, 0.15), linewidth = 1.3, label="Etot")
        
        # Configure energy panel
        xlims!(ax_eng, 0, maximum(times)); ax_eng.xlabel = "Time [-]"; ax_eng.ylabel = "Energy [-]"
        axislegend(ax_eng, position=:rt, framevisible=true)
    else
        # Single panel for initial snapshot (no energy data yet)
        fig = Figure(size = (720, 720))
        ax  = Axis(fig[1,1];
            backgroundcolor = :black,
            xticklabelcolor = :white, yticklabelcolor = :white,
            xlabelcolor = :white, ylabelcolor = :white,
            titlecolor = :white, xtickcolor=:white, ytickcolor=:white)
        
        # Color particles by speed
        speed = sqrt.((u.^2) .+ (v.^2) .+ (w.^2))
        smin = quantile(speed, 0.05); smax = max(quantile(speed, 0.95), smin + 1f-6)

        # Apply depth cueing if enabled
        sizes = fill(POINT_SIZE, length(x))
        if DEPTH_CUE
            zmin = quantile(z, 0.05); zmax = quantile(z, 0.95); zrange = max(zmax - zmin, 1f-3)
            depth = clamp.((z .- zmin) ./ zrange, 0f0, 1f0)
            sizes = POINT_SIZE .* (0.6 .+ 0.8 .* (1f0 .- depth))  # Nearer = bigger
        end

        # Plot particles
        scatter!(ax, x, y; color=speed, colormap=CMAP, colorrange=(smin,smax),
                 markersize=sizes, transparency=true)
        xlims!(ax, -BOUNDS, BOUNDS); ylims!(ax, -BOUNDS, BOUNDS)
        ax.aspect = DataAspect()
        ax.title = title_str
    end
    
    # Save and close
    save(path, fig)
end


"""
    render_animation_frame(path::AbstractString, x::AbstractVector{<:Real}, y::AbstractVector{<:Real},
                          z::AbstractVector{<:Real}, u::AbstractVector{<:Real},
                          v::AbstractVector{<:Real}, w::AbstractVector{<:Real})

Save a clean animation frame without ticks or labels.

Creates a clean image suitable for animation with:
- Black background (matching the galaxy visualization)
- No axis ticks, tick labels, or axis labels
- Just the particle positions with speed-based coloring
- Consistent with the main visualization style

# Arguments
- `path`: File path for saving the image
- `x, y, z, u, v, w`: Particle positions and velocities
"""
function render_animation_frame(path::AbstractString,
                               x::AbstractVector{<:Real}, y::AbstractVector{<:Real},
                               z::AbstractVector{<:Real}, u::AbstractVector{<:Real},
                               v::AbstractVector{<:Real}, w::AbstractVector{<:Real})
    
    # Create figure with black background (matching galaxy panel)
    fig = Figure(size = (720, 720), backgroundcolor = :black)
    ax = Axis(fig[1,1];
        backgroundcolor = :black,
        xticklabelcolor = :white, yticklabelcolor = :white,
        xlabelcolor = :white, ylabelcolor = :white,
        titlecolor = :white, xtickcolor=:white, ytickcolor=:white)
    
    # Color particles by speed
    speed = sqrt.((u.^2) .+ (v.^2) .+ (w.^2))
    smin = quantile(speed, 0.05); smax = max(quantile(speed, 0.95), smin + 1f-6)

    # Apply depth cueing if enabled
    sizes = fill(POINT_SIZE, length(x))
    if DEPTH_CUE
        zmin = quantile(z, 0.05); zmax = quantile(z, 0.95); zrange = max(zmax - zmin, 1f-3)
        depth = clamp.((z .- zmin) ./ zrange, 0f0, 1f0)
        sizes = POINT_SIZE .* (0.6 .+ 0.8 .* (1f0 .- depth))  # Nearer = bigger
    end

    # Plot particles
    scatter!(ax, x, y; color=speed, colormap=CMAP, colorrange=(smin,smax),
             markersize=sizes, transparency=true)
    
    # Configure plot appearance for clean animation frame
    xlims!(ax, -BOUNDS, BOUNDS); ylims!(ax, -BOUNDS, BOUNDS)
    ax.aspect = DataAspect()
    
    # Remove all ticks, labels, and grid for clean animation
    ax.xticks = (Float32[], String[])
    ax.yticks = (Float32[], String[])
    ax.xlabel = ""
    ax.ylabel = ""
    ax.title = ""
    
    # Remove spines for completely clean look
    ax.spinewidth = 0f0
    
    # Save and close
    save(path, fig)
end

"""
    setup_figure()

Create and configure the main visualization figure.

Sets up a 3-panel layout: positions (top 2/3) and energy (bottom 1/3).
The positions panel uses a dark theme, while the energy panel uses light theme.

# Returns
- `fig`: The main figure
- `ax_pos`: Axes for particle positions (dark theme)
- `ax_eng`: Axes for energy plots (light theme)
"""
function setup_figure()
    fig = Figure(size = (680, 820))
    grid = fig[1,1] = GridLayout()
    
    # Dark theme for positions panel
    ax_pos = Axis(grid[1:2,1];
        backgroundcolor = :black,
        xticklabelcolor = :white, yticklabelcolor = :white,
        xlabelcolor = :white, ylabelcolor = :white,
        titlecolor = :white, xtickcolor=:white, ytickcolor=:white)
    
    # Light theme for energy panel
    ax_eng = Axis(grid[3,1])
    
    return fig, ax_pos, ax_eng
end

# =============================================================================
# MAIN SIMULATION FUNCTION
# =============================================================================

"""
    main()

Main simulation function.

Implements the leapfrog integration scheme:
1. Half-kick: update velocities by half a time step
2. Drift: update positions by a full time step
3. Update accelerations (forces)
4. Half-kick: complete velocity update

This scheme conserves energy better than simple Euler integration.
The function handles both headless runs and real-time visualization.
"""
function main()
    # Display simulation configuration
    @info "Threads = $(Threads.nthreads())  | VISUALIZE=$(VISUALIZE)  | SYM=$(USE_SYM)"

    # Initialize particle system
    if IMPORT_IC !== nothing
        # Import initial conditions from file
        println("Importing initial conditions from: $IMPORT_IC")
        try
            x, y, z, u, v, w, m, file_G, file_softening = import_initial_conditions(IMPORT_IC)
            
            # Use parameters from the imported file
            G_actual = file_G
            softening_actual = file_softening
            N_actual = length(x)
            
            println("Using imported parameters: G=$G_actual, softening=$softening_actual, N=$N_actual")
            
            # Use imported N for the simulation
            if N_actual != N
                println("Warning: Imported N=$N_actual differs from configured N=$N")
                println("Using imported value: N=$N_actual")
            end
            
        catch e
            println("Error importing initial conditions: $e")
            println("Falling back to generated initial conditions...")
            x,y,z,u,v,w,m = init_ic(N, SEED, SCENARIO)
            G_actual = Gconst
            softening_actual = softening
            N_actual = N
        end
    else
        # Generate initial conditions using current method
        println("Initializing $(SCENARIO) scenario with $(N) particles...")
        x,y,z,u,v,w,m = init_ic(N, SEED, SCENARIO)
        G_actual = Gconst
        softening_actual = softening
        N_actual = N
    end
    
    # Allocate acceleration arrays
    ax = zeros(Float32, N_actual); ay = similar(ax); az = similar(ax)
    
    # Compute initial accelerations
    println("Computing initial forces...")
    compute_acc!(ax,ay,az, x,y,z,m, G_actual, softening_actual, USE_SYM)

    # Save initial snapshot if requested
    if STOREFINAL
        println("Saving initial snapshot...")
        render_snapshot("julia/nbody_$(SCENARIO)_initial_julia.png", x,y,z,u,v,w,
            "$(uppercasefirst(replace(SCENARIO, "_" => " "))) – initial")
    end

    # Time integration setup
    Nt = Int(ceil((tEnd)/dt))
    println("Running simulation for $(Nt) time steps (dt=$(dt), tEnd=$(tEnd))...")

    # ----- Real-time visualization setup -----
    if VISUALIZE
        println("Setting up visualization...")
        fig, ax_pos, ax_eng = setup_figure()

        # Observables for current positions & styling
        xobs   = Observable(copy(x))
        yobs   = Observable(copy(y))
        sizeo  = Observable(fill(POINT_SIZE, N))
        coloro = Observable(copy(sqrt.(u.^2 .+ v.^2 .+ w.^2)))
        crange = Observable((0f0, 1f0))

        # Main particle scatter plot
        scatter!(ax_pos, xobs, yobs;
                 color = coloro, colormap = CMAP, colorrange = crange,
                 markersize = sizeo, transparency = true)

        # Configure positions panel
        xlims!(ax_pos, -BOUNDS, BOUNDS); ylims!(ax_pos, -BOUNDS, BOUNDS)
        ax_pos.aspect = DataAspect()
        ax_pos.title = "$(uppercasefirst(replace(SCENARIO, "_" => " ")))  (N=$(N_actual))   t = 0.00"

        # Setup particle trails (optional)
        trail_xobs = Vector{Observable{Vector{Float32}}}()
        trail_yobs = Vector{Observable{Vector{Float32}}}()
        if TRAIL > 0
            resize!(trail_xobs, TRAIL); resize!(trail_yobs, TRAIL)
            
            # Trail appearance parameters
            alphas = TRAIL == 1 ? [0.25]              :
                     collect(range(0.08, 0.35; length = TRAIL))
            sizes_trail = TRAIL == 1 ? [0.7*POINT_SIZE] :
                          collect(range(0.5*POINT_SIZE, 0.9*POINT_SIZE; length = TRAIL))
            
            # Create trail observables
            for k in 1:TRAIL
                trail_xobs[k] = Observable(fill(NaN32, N_actual))
                trail_yobs[k] = Observable(fill(NaN32, N_actual))
                scatter!(ax_pos, trail_xobs[k], trail_yobs[k];
                         color = (0.7,0.7,1.0, alphas[k]),
                         markersize = sizes_trail[k], strokewidth = 0)
            end
        end
        trail_idx = 1

        # Energy tracking observables
        tobs  = Observable(Float32[0.0])
        KE0 = Float32(kinetic_energy(m, u, v, w))
        PE0 = Float32(potential_energy(x, y, z, m, G_actual, softening_actual))
        KEobs = Observable(Float32[KE0])
        PEobs = Observable(Float32[PE0])
        ETobs = Observable(Float32[KE0 + PE0])

        # Energy plots
        lines!(ax_eng, tobs, KEobs; color = (0.98, 0.42, 0.42), linewidth = 1.2, label="KE")
        lines!(ax_eng, tobs, PEobs; color = (0.30, 0.64, 1.00), linewidth = 1.2, label="PE")
        lines!(ax_eng, tobs, ETobs; color = (0.15, 0.15, 0.15), linewidth = 1.3, label="Etot")
        
        # Configure energy panel
        xlims!(ax_eng, 0, tEnd); ax_eng.xlabel = "time"; ax_eng.ylabel = "energy"
        axislegend(ax_eng, position=:rt, framevisible=true)
        
        # Display the figure
        display(fig)
    end

    # ----- Main time integration loop -----
    t = 0f0
    for it in 1:Nt
        # LEAPFROG INTEGRATION SCHEME
        
        # Step 1: Half-kick (update velocities by half a time step)
        @. u += 0.5f0 * dt * ax
        @. v += 0.5f0 * dt * ay
        @. w += 0.5f0 * dt * az
        
        # Step 2: Drift (update positions by full time step)
        @. x += dt * u
        @. y += dt * v
        @. z += dt * w
        
        # Step 3: Update accelerations (forces)
        compute_acc!(ax,ay,az, x,y,z,m, G_actual, softening_actual, USE_SYM)
        
        # Step 4: Complete the kick (update velocities by remaining half time step)
        @. u += 0.5f0 * dt * ax
        @. v += 0.5f0 * dt * ay
        @. w += 0.5f0 * dt * az
        
        t += dt

        # Periodic image saving for animation (only when STOREALL=true)
        if STOREALL && it % OUTPUT_STEP == 0
            # Create clean animation frame (no ticks, no labels, just particles)
            render_animation_frame(
                "julia/nbody_galaxy_spiral_$(lpad(FIGURE_NUM, 4, "0"))_julia.png",
                x, y, z, u, v, w
            )
            global FIGURE_NUM += 1  # Increment figure counter
        end

        # Real-time visualization updates
        if VISUALIZE
            # Track energy conservation
            KE = Float32(kinetic_energy(m,u,v,w))
            PE = Float32(potential_energy(x,y,z,m,Gconst,softening))
            KEobs[] = vcat(KEobs[], KE)
            PEobs[] = vcat(PEobs[], PE)
            ETobs[] = vcat(ETobs[], KE + PE)
            tobs[]  = vcat(tobs[],  Float32(t))

            # Update particle trails (ring buffer)
            if TRAIL > 0
                trail_xobs[trail_idx][] = copy(x)
                trail_yobs[trail_idx][] = copy(y)
                trail_idx = trail_idx % TRAIL + 1
            end

            # Update speed-based coloring
            speed = sqrt.(u.^2 .+ v.^2 .+ w.^2)
            smin = quantile(speed, 0.05); smax = max(quantile(speed, 0.95), smin+1f-6)
            coloro[] = speed
            crange[] = (smin, smax)

            # Apply depth cueing
            if DEPTH_CUE
                zmin = quantile(z, 0.05); zmax = quantile(z, 0.95); zrange = max(zmax - zmin, 1f-3)
                depth = clamp.((z .- zmin) ./ zrange, 0f0, 1f0)
                sizeo[] = POINT_SIZE .* (0.6 .+ 0.8 .* (1f0 .- depth))  # Nearer = bigger
            else
                sizeo[] = fill(POINT_SIZE, N)
            end

            # Update positions and title
            xobs[] = copy(x); yobs[] = copy(y)
            ax_pos.title = "$(uppercasefirst(replace(SCENARIO, "_" => " ")))  (N=$(N))   t = $(round(t; digits=2))"
            
            # Control visualization speed
            sleep(0.001)
        end
    end

    # Save final snapshot if requested
    if STOREFINAL
        println("Saving final snapshot...")
        if VISUALIZE
            # Save the existing live visualization figure (which already has correct styling)
            # This preserves the black background for galaxies panel and white background for energy panel
            save("julia/nbody_$(SCENARIO)_final_julia.png", current_figure())
        else
            # No energy data available when VISUALIZE=false
            # Create a simple snapshot with just particle positions
            render_snapshot("julia/nbody_$(SCENARIO)_final_julia.png", x,y,z,u,v,w,
                "$(uppercasefirst(replace(SCENARIO, "_" => " "))) – final  (t=$(round(t;digits=2)))")
        end
    end

    # Note: Final visualization is already saved above when VISUALIZE=true
    # No need to save the live visualization figure separately
    
    println("Simulation complete!")
end

# =============================================================================
# SCRIPT ENTRY POINT
# =============================================================================

# Run main function if script is executed directly
if isinteractive() || abspath(PROGRAM_FILE) == @__FILE__
    main()
end
