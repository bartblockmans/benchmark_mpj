function nbody()
% N-Body Galaxy Simulation in MATLAB
% ==================================
%
% This script simulates the gravitational dynamics of galaxies using an N-body approach.
% It implements an all-pairs gravity calculation with Plummer softening for numerical stability.
%
% Key Features:
% - Multiple simulation scenarios: spiral galaxy collision, simple galaxy collision, 
%   Plummer sphere, and random particle distribution
% - Leapfrog integration scheme for accurate orbital dynamics
% - Real-time visualization with particle trails and energy conservation plots
% - Optimized MATLAB implementation with single precision arithmetic
% - Symmetric force calculation to ensure momentum conservation
% - Import initial conditions from JSON files for reproducible results across languages
%
% Physics:
% - Gravitational force between all particle pairs (O(N²) complexity)
% - Plummer softening to prevent infinite forces at close encounters
% - Leapfrog integration: kick-drift-kick scheme for energy conservation
% - Center-of-mass frame to eliminate overall system drift
%
% Author: Bart Blockmans
% Date: August 2025
%
% Usage:
% - Set IMPORT_IC = [] to generate initial conditions using the current method
% - Set IMPORT_IC = 'filename.json' to import initial conditions from a JSON file
%   (e.g., 'nbody_ic_galaxy_spiral_N4000.json' generated by nbody_ic.py)
%
% Fairness tips for benchmarking:
% - Run MATLAB single-threaded: matlab -singleCompThread
% - Keep VISUALIZE=false during timing. STOREFINAL can be true to dump snapshots.

%% =============================================================================
% CONFIGURATION SECTION
% =============================================================================

% Visualization and Output Settings
VISUALIZE   = false;              % Enable real-time plotting (set to false for headless runs)
STOREFINAL  = true;               % Save initial & final PNGs to ./matlab/ directory
STOREALL    = true;               % Save all snapshots to ./matlab/ directory
USE_SYM     = true;               % Use symmetric i<j force loop for equal/opposite force updates

% Simulation Parameters
SCENARIO    = "galaxy_spiral";    % Simulation scenario: "galaxy_spiral" | "galaxy" | "plummer" | "random"
N           = 4000;               % Number of particles (increase when VISUALIZE=false)
tEnd        = single(3.0);        % Total simulation time
dt          = single(1e-3);       % Time step (small step maintains galaxy stability)
Gconst      = single(1.0);        % Gravitational constant (normalized units)
softening   = single(1.5e-2);     % Plummer softening parameter (prevents infinite forces)
SEED        = 17;                 % Random seed for reproducible results

% Initial Conditions Import
% Set to filename (e.g., 'nbody_ic_galaxy_spiral_N4000.json') to import initial conditions
% Set to [] to generate initial conditions using the current method
IMPORT_IC   = 'nbody_ic_galaxy_spiral_N4000.json';                 

% Visualization Parameters (only used when VISUALIZE=true or STOREFINAL=true)
TRAIL       = 1;                  % Number of time steps to show particle trails for realtime
FIGURE_NUM  = 1;                  % Sequential figure counter (separate from iteration number)
POINT_SIZE  = 5;                  % Size of current-position markers
CMAP        = 'parula';           % Color map for speed-based particle coloring
DEPTH_CUE   = true;               % Enable depth cueing (size/alpha based on z-coordinate)
BOUNDS      = single(3.5);        % Plot boundaries: x,y limits = ±BOUNDS
OUTPUT_STEP = 300;                % Frequency of output visualization

%% =============================================================================
% INITIAL CONDITIONS IMPORT FUNCTION
% =============================================================================

function [x, y, z, u, v, w, m, G_actual, softening_actual] = import_initial_conditions(filename)
    % IMPORT_INITIAL_CONDITIONS - Import initial conditions from JSON file
    %
    % This function reads initial conditions from a JSON file generated by nbody_ic.py
    % and returns the particle data along with simulation parameters.
    %
    % Inputs:
    %   filename - Path to the JSON file containing initial conditions
    %
    % Outputs:
    %   x, y, z - Particle positions (1D arrays)
    %   u, v, w - Particle velocities (1D arrays)
    %   m - Particle masses (1D array)
    %   G_actual - Gravitational constant from the file
    %   softening_actual - Softening parameter from the file
    %
    % Throws error if file doesn't exist or format is invalid
    
    % Check if file exists
    if ~exist(filename, 'file')
        error('Initial conditions file not found: %s', filename);
    end
    
    try
        % Read and parse JSON file
        fid = fopen(filename, 'r');
        if fid == -1
            error('Could not open file: %s', filename);
        end
        
        % Read entire file content
        file_content = fread(fid, '*char')';
        fclose(fid);
        
        % Parse JSON (MATLAB R2016b+ has built-in jsondecode)
        fprintf('MATLAB version: %s\n', version);
        fprintf('Checking jsondecode availability...\n');
        
        try
            data = jsondecode(file_content);
            fprintf('JSON parsing successful!\n');
        catch ME
            fprintf('Error during JSON parsing: %s\n', ME.message);
            fprintf('Error identifier: %s\n', ME.identifier);
            
            % Check if it's a version issue or something else
            if contains(ME.message, 'Undefined function') || contains(ME.message, 'jsondecode')
                error('MATLAB version too old. jsondecode requires R2016b+. Current error: %s', ME.message);
            else
                % Re-throw the original error if it's not a version issue
                rethrow(ME);
            end
        end
        
        % Validate file format
        if ~isfield(data, 'format_version')
            error('Invalid file format: missing ''format_version''');
        end
        
        if ~isfield(data, 'metadata') || ~isfield(data, 'particles')
            error('Invalid file format: missing ''metadata'' or ''particles'' sections');
        end
        
        % Extract metadata
        metadata = data.metadata;
        scenario = getfield_safe(metadata, 'scenario', 'unknown');
        file_N = getfield_safe(metadata, 'N', 0);
        file_G = getfield_safe(metadata, 'Gconst', 1.0);
        file_softening = getfield_safe(metadata, 'softening', 0.015);
        file_seed = getfield_safe(metadata, 'seed', 0);
        
        % Extract particle data
        particles = data.particles;
        x = single(particles.positions.x);
        y = single(particles.positions.y);
        z = single(particles.positions.z);
        u = single(particles.velocities.u);
        v = single(particles.velocities.v);
        w = single(particles.velocities.w);
        m = single(particles.masses);
        
        % Validate data consistency
        if length(x) ~= file_N
            error('Particle count mismatch: expected %d, got %d', file_N, length(x));
        end
        
        if length(x) ~= length(y) || length(x) ~= length(z) || ...
           length(x) ~= length(u) || length(x) ~= length(v) || ...
           length(x) ~= length(w) || length(x) ~= length(m)
            error('Inconsistent array lengths in particle data');
        end
        
        % Print import information
        fprintf('Imported initial conditions from: %s\n', filename);
        fprintf('  Scenario: %s\n', scenario);
        fprintf('  Particles: %d\n', file_N);
        fprintf('  G: %.6f\n', file_G);
        fprintf('  Softening: %.6f\n', file_softening);
        fprintf('  Seed: %d\n', file_seed);
        fprintf('  Generated by: %s\n', getfield_safe(metadata, 'generated_by', 'unknown'));
        fprintf('  Timestamp: %s\n', getfield_safe(metadata, 'timestamp', 'unknown'));
        
        % Return values
        G_actual = single(file_G);
        softening_actual = single(file_softening);
        
    catch ME
        error('Error reading initial conditions file: %s', ME.message);
    end
end

function value = getfield_safe(struct_data, field_name, default_value)
    % GETFIELD_SAFE - Safely get field value with default fallback
    if isfield(struct_data, field_name)
        value = struct_data.(field_name);
    else
        value = default_value;
    end
end

%% =============================================================================
% INITIALIZATION AND SETUP
% =============================================================================

% Create output directory for saved plots
thisdir = fileparts(mfilename('fullpath'));
OUT_DIR = fullfile(thisdir, 'matlab');
if ~exist(OUT_DIR,'dir'), mkdir(OUT_DIR); end

% Set random seed for reproducible results
rng(SEED, 'twister');

% Initialize particle system
if ~isempty(IMPORT_IC)
    % Import initial conditions from file
    fprintf('Importing initial conditions from: %s\n', IMPORT_IC);
    try
        [x, y, z, u, v, w, m, file_G, file_softening] = import_initial_conditions(IMPORT_IC);
        
        % Use parameters from the imported file
        G_actual = file_G;
        softening_actual = file_softening;
        N_actual = length(x);
        
        fprintf('Using imported parameters: G=%.6f, softening=%.6f, N=%d\n', ...
                G_actual, softening_actual, N_actual);
        
        % Use imported N for the simulation
        if N_actual ~= N
            fprintf('Warning: Imported N=%d differs from configured N=%d\n', N_actual, N);
            fprintf('Using imported value: N=%d\n', N_actual);
        end
        
    catch ME
        fprintf('Error importing initial conditions: %s\n', ME.message);
        fprintf('Falling back to generated initial conditions...\n');
        [x,y,z,u,v,w,m] = init_ic(N, SEED, SCENARIO);
        G_actual = Gconst;
        softening_actual = softening;
        N_actual = N;
    end
else
    % Generate initial conditions using current method
    fprintf('Initializing %s scenario with %d particles...\n', SCENARIO, N);
    [x,y,z,u,v,w,m] = init_ic(N, SEED, SCENARIO);
    G_actual = Gconst;
    softening_actual = softening;
    N_actual = N;
end

% Compute initial accelerations (forces)
fprintf('Computing initial forces...\n');
[ax,ay,az] = compute_acc(x,y,z,m, G_actual, softening_actual, USE_SYM);

% Save initial snapshot if requested
if STOREFINAL
    fprintf('Saving initial snapshot...\n');
    if VISUALIZE
        % Create initial energy arrays for the snapshot
        times_init = [0.0];
        KE_init = [kinetic_energy(m,u,v,w)];
        PE_init = [potential_energy(x,y,z,m,G_actual,softening_actual)];
        KP_init = [KE_init(1) + PE_init(1)];
        
        render_snapshot(fullfile(OUT_DIR, sprintf('nbody_%s_initial_matlab.png', SCENARIO)), ...
            x,y,z,u,v,w, BOUNDS, POINT_SIZE, CMAP, DEPTH_CUE, ...
            sprintf('%s – initial', capitalize_(SCENARIO)), ...
            times_init, KE_init, PE_init, KP_init);
    else
        % No energy data available when VISUALIZE=false
        render_snapshot(fullfile(OUT_DIR, sprintf('nbody_%s_initial_matlab.png', SCENARIO)), ...
            x,y,z,u,v,w, BOUNDS, POINT_SIZE, CMAP, DEPTH_CUE, ...
            sprintf('%s – initial', capitalize_(SCENARIO)), ...
            [], [], [], []);
    end
end

% Time integration setup
Nt = ceil(double(tEnd/dt));
t  = single(0);
fprintf('Running simulation for %d time steps (dt=%.1e, tEnd=%.1f)...\n', Nt, dt, tEnd);

%% =============================================================================
% VISUALIZATION SETUP
% =============================================================================

if VISUALIZE
    fprintf('Setting up visualization...\n');
    [fig, ax_pos, ax_eng] = setup_figure(); %#ok<NASGU>
    
    % Trail buffers for particle history (ring buffer structure)
    trail_x  = zeros(TRAIL, N_actual, 'single');    % X-positions for trail history
    trail_y  = zeros(TRAIL, N_actual, 'single');    % Y-positions for trail history
    trail_len = 0;                           % Current number of trail points
    trail_idx = 1;                           % Current position in ring buffer

    % Energy tracking arrays
    times  = zeros(1, Nt+1);                 % Time points
    KEsave = zeros(1, Nt+1);                 % Kinetic energy history
    PEsave = zeros(1, Nt+1);                 % Potential energy history
    KPsave = zeros(1, Nt+1);                 % Total energy history

    % Initial energy values
    KEsave(1) = kinetic_energy(m,u,v,w);
    PEsave(1) = potential_energy(x,y,z,m,G_actual,softening_actual);
    KPsave(1) = KEsave(1) + PEsave(1);
    times(1)  = 0.0;
end

%% =============================================================================
% MAIN TIME INTEGRATION LOOP
% =============================================================================

for it = 1:Nt
    % LEAPFROG INTEGRATION SCHEME
    %
    % This scheme conserves energy better than simple Euler integration:
    % 1. Half-kick: update velocities by half a time step
    % 2. Drift: update positions by a full time step  
    % 3. Update accelerations (forces)
    % 4. Complete the kick: update velocities by remaining half time step
    
    % Step 1: Half-kick (update velocities by half a time step)
    u = u + (single(0.5)*dt).*ax;
    v = v + (single(0.5)*dt).*ay;
    w = w + (single(0.5)*dt).*az;

    % Step 2: Drift (update positions by full time step)
    x = x + dt.*u;
    y = y + dt.*v;
    z = z + dt.*w;

    % Step 3: Update accelerations (forces)
    [ax,ay,az] = compute_acc(x,y,z,m, G_actual, softening_actual, USE_SYM);

    % Step 4: Complete the kick (update velocities by remaining half time step)
    u = u + (single(0.5)*dt).*ax;
    v = v + (single(0.5)*dt).*ay;
    w = w + (single(0.5)*dt).*az;

    t = t + dt;

    % Periodic image saving for animation (only when STOREALL=true)
    if STOREALL && mod(it, OUTPUT_STEP) == 0
        % Create clean animation frame (no ticks, no labels, just particles)
        render_animation_frame(fullfile(OUT_DIR, sprintf('nbody_galaxy_spiral_%04d_matlab.png', FIGURE_NUM)), ...
            x, y, z, u, v, w, BOUNDS, POINT_SIZE, CMAP, DEPTH_CUE);
        FIGURE_NUM = FIGURE_NUM + 1;  % Increment figure counter
    end

    % Real-time visualization updates
    if VISUALIZE
        % Track energy conservation (use double accumulator for numerical stability)
        KEsave(it+1) = kinetic_energy(m,u,v,w);
        PEsave(it+1) = potential_energy(x,y,z,m,G_actual,softening_actual);
        KPsave(it+1) = KEsave(it+1) + PEsave(it+1);
        times(it+1)  = double(t);

        % Update particle trails (ring buffer)
        trail_x(trail_idx,:) = x;
        trail_y(trail_idx,:) = y;
        trail_idx = mod(trail_idx, TRAIL) + 1;
        trail_len = min(trail_len + 1, TRAIL);
        idxs = mod((trail_idx - trail_len):(trail_idx-1), TRAIL) + 1;

        % Color particles by speed
        speed = sqrt(u.^2 + v.^2 + w.^2);
        [smin, smax] = percentiles(speed, 5, 95);
        smax = max(smax, smin + single(1e-6));
        colors = map_to_cmap(speed, smin, smax, CMAP);

        % Apply depth cueing if enabled
        if DEPTH_CUE
            [zmin, zmax] = percentiles(z, 5, 95);
            zrange = max(zmax - zmin, single(1e-3));
            depth  = min(max((z - zmin) ./ zrange, 0), 1);  % 0 = near, 1 = far
            sizes  = POINT_SIZE .* (0.6 + 0.8*(1 - depth)); % Nearer = bigger
            alphas = 0.6 + 0.4*(1 - depth);                  % Nearer = more opaque
        else
            sizes  = POINT_SIZE .* ones(size(x),'like',x);
            alphas = ones(size(x),'single');
        end

        % Draw positions panel (dark theme)
        cla(ax_pos);
        hold(ax_pos,'on');
        
        % Draw particle trails if enabled
        if trail_len > 1
            alphaTrail = linspace(0.08, 0.35, trail_len);
            sizeTrail  = linspace(0.5*POINT_SIZE, 0.9*POINT_SIZE, trail_len);
            for k = 1:trail_len
                xxk = trail_x(idxs(k),:);
                yyk = trail_y(idxs(k),:);
                scatter(ax_pos, double(xxk), double(yyk), sizeTrail(k), ...
                        [0.7 0.7 1.0], 'filled', ...
                        'MarkerFaceAlpha', alphaTrail(k), ...
                        'MarkerEdgeAlpha', 0);
            end
        end
        
        % Draw current particle positions with per-point sizes & alphas
        S = scatter(ax_pos, double(x), double(y), double(sizes), ...
                    colors(:,1:3), 'filled'); % Per-point colors (RGB)
        
        % Set per-point alpha if supported (R2018b+)
        try
            S.MarkerFaceAlpha = 'flat';
            S.AlphaData = double(alphas(:));
        catch
            S.MarkerFaceAlpha = 0.9;  % Fallback for older MATLAB versions
        end
        
        % Configure positions panel
        axis(ax_pos,'image');
        xlim(ax_pos, double([-BOUNDS, BOUNDS]));
        ylim(ax_pos, double([-BOUNDS, BOUNDS]));
        title(ax_pos, sprintf('%s  (N=%d)   t = %.2f', ...
            capitalize_(SCENARIO), N, double(t)));
        hold(ax_pos,'off');

        % Update energy panel (light theme)
        cla(ax_eng);
        hold(ax_eng,'on');
        plot(ax_eng, times(1:it+1), KEsave(1:it+1), 'Color',[0.8 0.2 0.2], 'LineWidth',1.1);
        plot(ax_eng, times(1:it+1), PEsave(1:it+1), 'Color',[0.2 0.4 0.9], 'LineWidth',1.1);
        plot(ax_eng, times(1:it+1), KPsave(1:it+1), 'Color',[0.15 0.15 0.15], 'LineWidth',1.2);
        xlim(ax_eng, [0, double(tEnd)]);
        xlabel(ax_eng,'Time [-]'); ylabel(ax_eng,'Energy [-]');
        legend(ax_eng,{'KE','PE','Etot'},'Location','northeast');
        hold(ax_eng,'off');

        % Update display (limit rate for smooth animation)
        drawnow limitrate nocallbacks;
    end
end

%% =============================================================================
% FINAL OUTPUT AND CLEANUP
% =============================================================================

% Save final snapshot if requested
if STOREFINAL
    fprintf('Saving final snapshot...\n');
    if VISUALIZE
        % Save the existing live visualization figure (which already has correct styling)
        % This preserves the black background for galaxies panel and white background for energy panel
        exportgraphics(gcf, fullfile(OUT_DIR, sprintf('nbody_%s_final_matlab.png', SCENARIO)), 'Resolution',220);
    else
        % No energy data available when VISUALIZE=false
        % Create a simple snapshot with just particle positions
        render_snapshot(fullfile(OUT_DIR, sprintf('nbody_%s_final_matlab.png', SCENARIO)), ...
            x,y,z,u,v,w, BOUNDS, POINT_SIZE, CMAP, DEPTH_CUE, ...
            sprintf('%s – final  (t = %.2f)', capitalize_(SCENARIO), double(t)), ...
            [], [], [], []);
    end
end

% Note: Final visualization is already saved above when VISUALIZE=true
% No need to save the live visualization figure separately

fprintf('Simulation complete!\n');

end % ---- end main function ----


%% =============================================================================
% CORE PHYSICS FUNCTIONS
% =============================================================================

function [ax,ay,az] = compute_acc(x,y,z,m,G,epsi,use_sym)
% COMPUTE_ACC - Compute gravitational acceleration for all particles
%
% This is the computationally intensive O(N²) part of the simulation.
% Uses Plummer softening to prevent infinite forces at close encounters.
%
% Inputs:
%   x, y, z - Particle position vectors (single precision)
%   m       - Particle mass vector (single precision)
%   G       - Gravitational constant
%   epsi    - Softening parameter (Plummer radius)
%   use_sym - If true, use symmetric i<j loop for equal/opposite forces
%
% Outputs:
%   ax, ay, az - Acceleration component vectors (single precision)
%
% Algorithm:
%   - If use_sym=true: Compute force between each pair only once (more efficient)
%   - If use_sym=false: Compute all N² forces explicitly (slower but more explicit)
%   - Applies Plummer softening: r² → r² + ε² to prevent infinite forces

    N   = numel(x);
    ax  = zeros(N,1,'single');
    ay  = zeros(N,1,'single');
    az  = zeros(N,1,'single');
    eps2 = epsi * epsi;  % Softening parameter squared

    if use_sym
        % Symmetric loop: compute force between each pair only once
        % This is more efficient and ensures exact momentum conservation
        for i = 1:N-1
            xi = x(i); yi = y(i); zi = z(i); mi = m(i);  % Position and mass of particle i
            
            for j = i+1:N
                % Vector from particle i to particle j
                dx = x(j)-xi; dy = y(j)-yi; dz = z(j)-zi;
                
                % Distance squared with softening (prevents infinite forces)
                r2 = dx*dx + dy*dy + dz*dz + eps2;
                
                % Compute 1/r and 1/r³ for force calculation
                invr  = single(1) ./ sqrt(r2);   % 1/r
                invr3 = invr ./ r2;              % 1/r³
                
                % Force magnitude (scalar)
                s = G * invr3;                   % No mass here; add below
                
                % Force vector components
                fx = s * dx; fy = s * dy; fz = s * dz;
                
                % Apply equal and opposite forces (Newton's 3rd law)
                % Particle i feels force from particle j
                ax(i) = ax(i) + m(j)*fx;  ay(i) = ay(i) + m(j)*fy;  az(i) = az(i) + m(j)*fz;
                % Particle j feels equal and opposite force from particle i
                ax(j) = ax(j) - mi  *fx;  ay(j) = ay(j) - mi  *fy;  az(j) = az(j) - mi  *fz;
            end
        end
    else
        % Non-symmetric loop: compute all N² forces explicitly
        % This is slower but more straightforward to understand
        for i = 1:N
            xi=x(i); yi=y(i); zi=z(i);
            aix = single(0); aiy = single(0); aiz = single(0);  % Accumulate accelerations for particle i
            
            for j = 1:N
                if j==i, continue; end  % Skip self-interaction
                
                % Vector from particle i to particle j
                dx = x(j)-xi; dy = y(j)-yi; dz = z(j)-zi;
                
                % Distance squared with softening
                r2 = dx*dx + dy*dy + dz*dz + eps2;
                invr  = single(1) ./ sqrt(r2);
                invr3 = invr ./ r2;
                
                % Force on particle i due to particle j
                s = G * m(j) * invr3;
                aix = aix + s*dx; aiy = aiy + s*dy; aiz = aiz + s*dz;
            end
            
            % Store accumulated accelerations
            ax(i)=aix; ay(i)=aiy; az(i)=aiz;
        end
    end
end

function ke = kinetic_energy(m,u,v,w)
% KINETIC_ENERGY - Compute total kinetic energy of the system
%
% KE = Σ(½ × m × v²) for all particles
%
% Inputs:
%   m, u, v, w - Particle masses and velocity components
%
% Outputs:
%   ke - Total kinetic energy (double precision for numerical stability)
%
% Note: Uses double accumulator for numerical stability (fair comparison with Python/Julia)

ke = 0.0;
for i = 1:numel(m)
    % Velocity squared for particle i
    s = double(u(i))*double(u(i)) + double(v(i))*double(v(i)) + double(w(i))*double(w(i));
    ke = ke + 0.5*double(m(i))*s;
end
end

function pe = potential_energy(x,y,z,m,G,epsi)
% POTENTIAL_ENERGY - Compute total gravitational potential energy of the system
%
% PE = -G × Σ(mᵢ × mⱼ / rᵢⱼ) for all particle pairs
%
% Inputs:
%   x, y, z, m - Particle positions and masses
%   G           - Gravitational constant
%   epsi        - Softening parameter
%
% Outputs:
%   pe - Total potential energy (double precision for numerical stability)

N = numel(x); pe = 0.0;
eps2 = double(epsi)*double(epsi);

% Sum over all particle pairs (i < j to avoid double counting)
for i = 1:N-1
    xi = double(x(i)); yi=double(y(i)); zi=double(z(i)); mi=double(m(i));
    
    for j = i+1:N
        % Distance between particles i and j
        dx = double(x(j))-xi; dy = double(y(j))-yi; dz = double(z(j))-zi;
        r  = sqrt(dx*dx + dy*dy + dz*dz + eps2);
        
        % Gravitational potential energy between this pair
        pe = pe - double(G)*mi*double(m(j))/r;
    end
end
end

%% =============================================================================
% INITIAL CONDITION GENERATORS
% =============================================================================

function [x,y,z,u,v,w,m] = init_ic(N, seed, scenario)
% INIT_IC - Generate initial conditions for the N-body simulation
%
% Creates different particle distributions based on the selected scenario.
% All scenarios are set up in the center-of-mass frame for numerical stability.
%
% Inputs:
%   N        - Number of particles
%   seed     - Random seed for reproducible results
%   scenario - Initial condition type: "galaxy_spiral", "galaxy", "plummer", or "random"
%
% Outputs:
%   x, y, z, u, v, w, m - Initial particle positions, velocities, and masses

rng(seed, 'twister');

switch string(scenario)
    case "galaxy_spiral"
        % Two spiral galaxies on collision course
        N1 = floor(N/2); N2 = N - N1;
        
        % Different initial phases for the two galaxies
        phi1 = 2*pi*rand(1,'single');
        phi2 = phi1 + single(pi)/3;

        % Generate first spiral galaxy
        [x1,y1,z1,u1,v1,w1,m1] = spiral_disk(N1, single(10.0), ...
            'Rd',0.55,'Rmax',1.7,'m',2,'pitch_deg',18,'arm_amp',0.70, ...
            'z_thick',0.07,'v0',1.05,'v_rise',0.32,'nudge_r',0.06,'nudge_t',0.03, ...
            'jitter',0.025,'phi0',phi1);

        % Generate second spiral galaxy
        [x2,y2,z2,u2,v2,w2,m2] = spiral_disk(N2, single(10.0), ...
            'Rd',0.55,'Rmax',1.7,'m',2,'pitch_deg',18,'arm_amp',0.70, ...
            'z_thick',0.07,'v0',1.05,'v_rise',0.32,'nudge_r',0.06,'nudge_t',0.03, ...
            'jitter',0.025,'phi0',phi2);

        % Reverse velocity of second galaxy and offset positions
        u2 = -u2; v2 = -v2;  % Counter-rotating
        d = single(2.1); vcm = single(0.45);  % Initial separation and center-of-mass velocity
        
        % Position and velocity offsets for collision
        x1 = x1 - d; v1 = v1 + vcm;
        x2 = x2 + d; v2 = v2 - vcm;

        % Combine the two galaxies
        x = [x1; x2]; y = [y1; y2]; z = [z1; z2];
        u = [u1; u2]; v = [v1; v2]; w = [w1; w2];
        m = [m1; m2];

    case "galaxy"
        % Two simple disk galaxies on collision course
        N1 = floor(N/2); N2 = N - N1;
        
        % Generate two identical disk galaxies
        [x1,y1,z1,u1,v1,w1,m1] = disk(N1, single(10.0), 'Rmax',1.1,'z_thick',0.08,'v_rot',1.0,'jitter',0.05);
        [x2,y2,z2,u2,v2,w2,m2] = disk(N2, single(10.0), 'Rmax',1.1,'z_thick',0.08,'v_rot',1.0,'jitter',0.05);
        
        % Counter-rotating galaxies
        u2 = -u2; v2 = -v2;
        d = single(2.0); vcm = single(0.5);  % Initial separation and center-of-mass velocity
        
        % Position and velocity offsets
        x1 = x1 - d; v1 = v1 + vcm;
        x2 = x2 + d; v2 = v2 - vcm;

        % Combine the galaxies
        x = [x1; x2]; y = [y1; y2]; z = [z1; z2];
        u = [u1; u2]; v = [v1; v2]; w = [w1; w2];
        m = [m1; m2];

    case "plummer"
        % Plummer sphere: a realistic model for globular clusters
        a = single(0.5);  % Scale radius
        
        % Generate positions using Plummer distribution
        U = rand(N,1,'single');
        r = a ./ sqrt(U.^(-2/3) - 1 + 1e-6);  % Radial distribution
        
        % Random spherical angles
        phi = 2*pi*rand(N,1,'single');      % Azimuthal
        cos_t = 2*rand(N,1,'single') - 1;   % Cosine of polar
        sin_t = sqrt(max(0,1 - cos_t.^2));  % Sine of polar
        
        % Convert to Cartesian coordinates
        x = r .* sin_t .* cos(phi);
        y = r .* sin_t .* sin(phi);
        z = r .* cos_t;
        
        % Small random velocities
        u = 0.02*randn(N,1,'single');
        v = 0.02*randn(N,1,'single');
        w = 0.02*randn(N,1,'single');
        m = (20.0/single(N)) * ones(N,1,'single');

    otherwise % "random"
        % Random particle distribution (useful for testing)
        x = randn(N,1,'single'); y = randn(N,1,'single'); z = randn(N,1,'single');
        u = randn(N,1,'single'); v = randn(N,1,'single'); w = randn(N,1,'single');
        m = (20.0/single(N)) * ones(N,1,'single');
end

% Transform to center-of-mass frame for numerical stability
% This prevents the entire system from drifting
mu = mean(m .* u); mv = mean(m .* v); mw = mean(m .* w);
mbar = mean(m);
u = u - mu/mbar; v = v - mv/mbar; w = w - mw/mbar;
end

function [x,y,z,u,v,w,m] = disk(N, mass_total, varargin)
% DISK - Generate initial conditions for a rotating stellar disk
%
% Creates a 2D disk with small thickness in the z-direction.
% Particles are distributed with circular velocities for orbital stability.
%
% Inputs:
%   N           - Number of particles
%   mass_total  - Total mass of the disk
%   varargin    - Optional parameters (see below)
%
% Optional Parameters:
%   Rmax        - Maximum radius of the disk (default: 1.2)
%   z_thick     - Thickness of the disk in z-direction (default: 0.1)
%   v_rot       - Rotation velocity scaling factor (default: 0.9)
%   jitter      - Random velocity perturbation magnitude (default: 0.05)
%
% Outputs:
%   x, y, z, u, v, w, m - Particle positions, velocities, and masses

% Parse optional parameters
p = inputParser;
addParameter(p,'Rmax',single(1.2));
addParameter(p,'z_thick',single(0.1));
addParameter(p,'v_rot',single(0.9));
addParameter(p,'jitter',single(0.05));
parse(p, varargin{:});
Rmax=p.Results.Rmax; z_thick=p.Results.z_thick; v_rot=p.Results.v_rot; jitter=p.Results.jitter;

% Generate radial positions (more particles near center)
R = Rmax * sqrt(rand(N,1,'single'));

% Generate random azimuthal angles
theta = 2*pi*rand(N,1,'single');

% Convert to Cartesian coordinates
x = R.*cos(theta); y=R.*sin(theta); z=(z_thick*0.5).*randn(N,1,'single');

% Circular velocity for orbital stability
% v = v_rot × R / (0.3 + R) gives a realistic rotation curve
vtan = v_rot .* R ./ (0.3 + R);
u = -vtan .* sin(theta); v = vtan .* cos(theta); w = zeros(N,1,'single');

% Add random velocity perturbations for realistic dynamics
u = u + jitter*randn(N,1,'single');
v = v + jitter*randn(N,1,'single');
w = w + 0.5*jitter*randn(N,1,'single');

% Equal mass particles
m = (mass_total/single(N)) * ones(N,1,'single');
end

function [x,y,z,u,v,w,m] = spiral_disk(N, mass_total, varargin)
% SPIRAL_DISK - Generate initial conditions for a spiral galaxy disk
%
% Creates an exponential disk with logarithmic spiral arm overdensities.
% This produces more realistic galaxy morphologies than simple disks.
%
% Inputs:
%   N           - Number of particles
%   mass_total  - Total mass of the disk
%   varargin    - Optional parameters (see below)
%
% Optional Parameters:
%   Rd          - Disk scale length (exponential falloff, default: 0.6)
%   Rmax        - Maximum disk radius (default: 1.8)
%   m           - Number of spiral arms (default: 2)
%   pitch_deg   - Pitch angle of spiral arms in degrees (default: 18)
%   arm_amp     - Amplitude of spiral arm overdensity (default: 0.65)
%   z_thick     - Disk thickness (default: 0.08)
%   v0          - Circular velocity at large radius (default: 1.0)
%   v_rise      - Radius where velocity reaches v0 (default: 0.35)
%   nudge_r     - Radial velocity perturbations for spiral structure (default: 0.05)
%   nudge_t     - Tangential velocity perturbations for spiral structure (default: 0.02)
%   jitter      - Random velocity perturbation (default: 0.03)
%   phi0        - Initial phase angle for spiral arms (default: random)
%
% Outputs:
%   x, y, z, u, v, w, m - Particle positions, velocities, and masses

% Parse optional parameters
p = inputParser;
addParameter(p,'Rd',single(0.6));
addParameter(p,'Rmax',single(1.8));
addParameter(p,'m',2);
addParameter(p,'pitch_deg',single(18));
addParameter(p,'arm_amp',single(0.65));
addParameter(p,'z_thick',single(0.08));
addParameter(p,'v0',single(1.0));
addParameter(p,'v_rise',single(0.35));
addParameter(p,'nudge_r',single(0.05));
addParameter(p,'nudge_t',single(0.02));
addParameter(p,'jitter',single(0.03));
addParameter(p,'phi0',[]);
parse(p, varargin{:});
Rd=p.Results.Rd; Rmax=p.Results.Rmax; mArm=p.Results.m; pitch_deg=p.Results.pitch_deg;
arm_amp=p.Results.arm_amp; z_thick=p.Results.z_thick; v0=p.Results.v0; v_rise=p.Results.v_rise;
nudge_r=p.Results.nudge_r; nudge_t=p.Results.nudge_t; jitter=p.Results.jitter; phi0=p.Results.phi0;

% Set initial phase if not provided
if isempty(phi0), phi0 = single(2*pi*rand()); end

% Generate radial positions using gamma distribution (more realistic than uniform)
% Gamma(k=2, θ=Rd) via -θ*log(U1*U2), truncated to Rmax
R = Rd .* (-log(rand(N,1,'single') .* rand(N,1,'single')));

% Ensure all particles are within Rmax
while true
    mask = R > Rmax;
    if ~any(mask), break; end
    R(mask) = Rd .* (-log(rand(nnz(mask),1,'single') .* rand(nnz(mask),1,'single')));
end

% Generate azimuthal angles with spiral arm overdensity using rejection sampling
k = single(1) / tan(deg2rad(double(pitch_deg)));  % Spiral pitch parameter
theta = zeros(N,1,'single');
filled = 0;

% Use rejection sampling to create spiral arm structure
while filled < N
    need = N - filled;
    th_try = (2*pi) * rand(2*need,1,'single');
    Rrep   = repmat(R(filled+1:filled+need), 2, 1);
    
    % Probability density for spiral arms
    pacc   = 1 + arm_amp .* cos(single(mArm) .* (th_try - single(k)*log(Rrep + 1e-6) - phi0));
    uacc   = (1 + arm_amp) * rand(2*need,1,'single');
    
    % Accept particles based on spiral arm probability
    keep   = uacc < pacc;
    nkeep  = min(need, nnz(keep));
    theta(filled+1:filled+nkeep) = th_try(find(keep, nkeep, 'first'));
    filled = filled + nkeep;
end

% Convert to Cartesian coordinates
x = R.*cos(theta); y = R.*sin(theta); z = (z_thick*0.5).*randn(N,1,'single');

% Velocity field with spiral structure
v_circ = v0 .* tanh(R ./ v_rise);  % Circular velocity
phase  = single(mArm) .* (theta - single(k)*log(R + 1e-6) - phi0);  % Spiral phase

% Velocity perturbations aligned with spiral arms
v_r = nudge_r .* v_circ .* cos(phase);  % Radial velocity
v_t = v_circ .* (1 + nudge_t .* sin(phase));  % Tangential velocity

% Convert to Cartesian velocity components
u = -v_t .* sin(theta) + v_r .* cos(theta);
v =  v_t .* cos(theta) + v_r .* sin(theta);
w =  0.5*jitter .* randn(N,1,'single');

% Add random perturbations
u = u + jitter*randn(N,1,'single');
v = v + jitter*randn(N,1,'single');

% Equal mass particles
m = (mass_total/single(N)) * ones(N,1,'single');
end

%% =============================================================================
% VISUALIZATION HELPER FUNCTIONS
% =============================================================================

function [fig, ax_pos, ax_eng] = setup_figure()
% SETUP_FIGURE - Create and configure the main visualization figure
%
% Sets up a 3-panel layout: positions (top 2/3) and energy (bottom 1/3).
% The positions panel uses a dark theme, while the energy panel uses light theme.
%
% Outputs:
%   fig     - The main figure handle
%   ax_pos  - Axes for particle positions (dark theme)
%   ax_eng  - Axes for energy plots (light theme)

fig = figure('Color','w','Position',[100 100 680 820]);
tiledlayout(fig,3,1,'Padding','compact','TileSpacing','compact');

% Upper 2 tiles merged for positions (dark theme)
nexttile([2 1]);
ax_pos = gca;
style_axes_dark(ax_pos);

% Bottom tile for energies (light theme)
nexttile(3);
ax_eng = gca;
style_axes_light(ax_eng);
end

function style_axes_dark(ax)
% STYLE_AXES_DARK - Apply dark theme styling to a MATLAB axis
%
% Inputs:
%   ax - Axis handle to style

set(ax,'Color','k');
ax.XColor = [0.8 0.8 0.8];
ax.YColor = [0.8 0.8 0.8];
ax.Title.Color = [1 1 1];
ax.XLabel.Color = [1 1 1];
ax.YLabel.Color = [1 1 1];
set(ax, 'Box','on','LineWidth',0.8);
end

function style_axes_light(ax)
% STYLE_AXES_LIGHT - Apply light theme styling to a MATLAB axis
%
% Inputs:
%   ax - Axis handle to style

set(ax,'Color','w');
ax.XColor = [0.1 0.1 0.1];
ax.YColor = [0.1 0.1 0.1];
ax.Title.Color = [0.1 0.1 0.1];
ax.XLabel.Color = [0.1 0.1 0.1];
ax.YLabel.Color = [0.1 0.1 0.1];
set(ax, 'Box','on','LineWidth',0.8);
end

function render_snapshot(path, x,y,z,u,v,w, BOUNDS, POINT_SIZE, CMAP, DEPTH_CUE, titleStr, times, KEsave, PEsave, KPsave)
% RENDER_SNAPSHOT - Save a two-panel snapshot matching the live visualization
%
% Creates a standalone figure with the same layout as the live visualization:
% - Top panel: Particle positions with dark theme (black background)
% - Bottom panel: Energy evolution with light theme (white background)
%
% Inputs:
%   path       - File path for saving the image
%   x, y, z, u, v, w - Particle positions and velocities
%   BOUNDS     - Plot boundaries
%   POINT_SIZE - Size of particle markers
%   CMAP       - Color map name
%   DEPTH_CUE  - Whether to enable depth cueing
%   titleStr   - Title for the plot
%   times      - Time points for energy history (can be empty for initial snapshots)
%   KEsave     - Kinetic energy history (can be empty for initial snapshots)
%   PEsave     - Potential energy history (can be empty for initial snapshots)
%   KPsave     - Total energy history (can be empty for initial snapshots)

if ~isempty(times) && ~isempty(KEsave) && ~isempty(PEsave) && ~isempty(KPsave) && length(times) > 1
    % Two-panel layout matching live visualization (when we have multiple time points)
    fig = figure('Color','w','Position',[100 100 680 820]);
    tiledlayout(fig,3,1,'Padding','compact','TileSpacing','compact');

    % Upper 2 tiles merged for positions (dark theme) - same as live visualization
    nexttile([2 1]);
    ax_pos = gca;
    style_axes_dark(ax_pos);  % This ensures black background

    % Color particles by speed
    speed = sqrt(u.^2 + v.^2 + w.^2);
    [smin,smax] = percentiles(speed, 5, 95);
    smax = max(smax, smin + single(1e-6));
    colors = map_to_cmap(speed, smin, smax, CMAP);

    % Apply depth cueing if enabled
    if DEPTH_CUE
        [zmin,zmax] = percentiles(z, 5, 95);
        zrange = max(zmax - zmin, single(1e-3));
        depth  = min(max((z - zmin) ./ zrange, 0), 1);
        sizes  = POINT_SIZE .* (0.6 + 0.8*(1 - depth));  % Nearer = bigger
        alphas = 0.6 + 0.4*(1 - depth);                   % Nearer = more opaque
    else
        sizes  = POINT_SIZE .* ones(size(x),'like',x);
        alphas = ones(size(x),'single');
    end

    % Plot particles
    S = scatter(ax_pos, double(x), double(y), double(sizes), colors(:,1:3), 'filled');

    % Set per-point alpha if supported
    try
        S.MarkerFaceAlpha = 'flat';
        S.AlphaData = double(alphas(:));
    catch
        S.MarkerFaceAlpha = 0.9;  % Fallback for older MATLAB versions
    end

    % Configure positions panel
    axis(ax_pos,'image');
    xlim(ax_pos, double([-BOUNDS, BOUNDS]));
    ylim(ax_pos, double([-BOUNDS, BOUNDS]));
    title(ax_pos, titleStr);

    % Bottom tile for energies (light theme) - same as live visualization
    nexttile(3);
    ax_eng = gca;
    style_axes_light(ax_eng);  % This ensures white background

    % Plot energy evolution
    hold(ax_eng,'on');
    plot(ax_eng, times, KEsave, 'Color',[0.8 0.2 0.2], 'LineWidth',1.1);
    plot(ax_eng, times, PEsave, 'Color',[0.2 0.4 0.9], 'LineWidth',1.1);
    plot(ax_eng, times, KPsave, 'Color',[0.15 0.15 0.15], 'LineWidth',1.2);
    xlim(ax_eng, [0, max(times)]);
    xlabel(ax_eng,'Time [-]'); ylabel(ax_eng,'Energy [-]');
    legend(ax_eng,{'KE','PE','Etot'},'Location','northeast');
    hold(ax_eng,'off');
else
    % Single panel for initial snapshot (no energy data yet or single time point)
    fig = figure('Color','w','Position',[100 100 720 720]); 
    axh = axes(fig); 

    % Color particles by speed
    speed = sqrt(u.^2 + v.^2 + w.^2);
    [smin,smax] = percentiles(speed, 5, 95);
    smax = max(smax, smin + single(1e-6));
    colors = map_to_cmap(speed, smin, smax, CMAP);

    % Apply depth cueing if enabled
    if DEPTH_CUE
        [zmin,zmax] = percentiles(z, 5, 95);
        zrange = max(zmax - zmin, single(1e-3));
        depth  = min(max((z - zmin) ./ zrange, 0), 1);
        sizes  = POINT_SIZE .* (0.6 + 0.8*(1 - depth));  % Nearer = bigger
        alphas = 0.6 + 0.4*(1 - depth);                   % Nearer = more opaque
    end

    % Plot particles
    S = scatter(axh, double(x), double(y), double(sizes), colors(:,1:3), 'filled');

    % Set per-point alpha if supported
    try
        S.MarkerFaceAlpha = 'flat';
        S.AlphaData = double(alphas(:));
    catch
        S.MarkerFaceAlpha = 0.9;  % Fallback for older MATLAB versions
    end

    % Configure plot appearance
    axis(axh,'image');
    style_axes_dark(axh);  % This ensures black background for initial snapshots too
    xlim(axh, double([-BOUNDS, BOUNDS]));
    ylim(axh, double([-BOUNDS, BOUNDS]));
    title(axh, titleStr); xlabel(axh,'x'); ylabel(axh,'y');
end

% Save and close
exportgraphics(fig, path, 'Resolution',220);
close(fig);
end

function render_animation_frame(path, x, y, z, u, v, w, BOUNDS, POINT_SIZE, CMAP, DEPTH_CUE)
% RENDER_ANIMATION_FRAME - Save a clean animation frame without ticks or labels
%
% Creates a clean image suitable for animation with:
% - Black background (matching the galaxy visualization)
% - No axis ticks, tick labels, or axis labels
% - Just the particle positions with speed-based coloring
% - Consistent with the main visualization style
%
% Inputs:
%   path       - File path for saving the image
%   x, y, z, u, v, w - Particle positions and velocities
%   BOUNDS     - Plot boundaries
%   POINT_SIZE - Size of particle markers
%   CMAP       - Color map name
%   DEPTH_CUE  - Whether to enable depth cueing

% Create figure with black background (matching galaxy panel)
fig = figure('Color','k','Position',[100 100 720 720]); 
axh = axes(fig); 

% Color particles by speed
speed = sqrt(u.^2 + v.^2 + w.^2);
[smin,smax] = percentiles(speed, 5, 95);
smax = max(smax, smin + single(1e-6));
colors = map_to_cmap(speed, smin, smax, CMAP);

% Apply depth cueing if enabled
if DEPTH_CUE
    [zmin,zmax] = percentiles(z, 5, 95);
    zrange = max(zmax - zmin, single(1e-3));
    depth  = min(max((z - zmin) ./ zrange, 0), 1);
    sizes  = POINT_SIZE .* (0.6 + 0.8*(1 - depth));  % Nearer = bigger
    alphas = 0.6 + 0.4*(1 - depth);                   % Nearer = more opaque
else
    sizes  = POINT_SIZE .* ones(size(x),'like',x);
    alphas = ones(size(x),'single');
end

% Plot particles
S = scatter(axh, double(x), double(y), double(sizes), colors(:,1:3), 'filled');

% Set per-point alpha if supported
try
    S.MarkerFaceAlpha = 'flat';
    S.AlphaData = double(alphas(:));
catch
    S.MarkerFaceAlpha = 0.9;  % Fallback for older MATLAB versions
end

% Configure plot appearance for clean animation frame
axis(axh,'image');
xlim(axh, double([-BOUNDS, BOUNDS]));
ylim(axh, double([-BOUNDS, BOUNDS]));

% Remove all ticks, labels, and grid for clean animation
set(axh, 'XTick', [], 'YTick', [], 'XTickLabel', [], 'YTickLabel', []);
set(axh, 'XLabel', [], 'YLabel', []);
set(axh, 'Title', []);
set(axh, 'Box', 'off');
set(axh, 'Color', 'k');  % Ensure black background

% Save and close
exportgraphics(fig, path, 'Resolution',220);
close(fig);
end

%% =============================================================================
% UTILITY FUNCTIONS
% =============================================================================

function [pL, pH] = percentiles(v, pLo, pHi)
% PERCENTILES - Simple percentile calculation (no toolboxes required)
%
% Consistent with Python np.percentile for fair comparison across languages
%
% Inputs:
%   v   - Input vector
%   pLo - Lower percentile (0-100)
%   pHi - Upper percentile (0-100)
%
% Outputs:
%   pL, pH - Lower and upper percentile values

s = sort(double(v(:)));
n = numel(s);
iL = max(1, min(n, round((pLo/100)*(n-1)+1)));
iH = max(1, min(n, round((pHi/100)*(n-1)+1)));
pL = single(s(iL)); pH = single(s(iH));
end

function C = map_to_cmap(values, vmin, vmax, cmapName)
% MAP_TO_CMAP - Map scalar values to RGB colors using a MATLAB colormap
%
% Inputs:
%   values   - Scalar values to map (single precision)
%   vmin     - Minimum value for color mapping
%   vmax     - Maximum value for color mapping
%   cmapName - Name of MATLAB colormap function
%
% Outputs:
%   C - Nx3 RGB color matrix (double precision)

v = double(values);
v = (v - double(vmin)) / max(double(vmax-vmin), 1e-12);
v = min(max(v,0),1);

n = 256;
try
    cmap = feval(cmapName, n);
catch
    cmap = parula(n);  % Fallback to default colormap
end

idx = max(1, min(n, 1 + floor(v * (n-1))));
C = cmap(idx, :); % Nx3 double
end

function out = capitalize_(s)
% CAPITALIZE_ - Capitalize first letter and replace underscores with spaces
%
% Inputs:
%   s - Input string
%
% Outputs:
%   out - Capitalized string with underscores replaced by spaces

s = string(s);
s = replace(s, "_"," ");
if strlength(s) == 0, out = s; return; end
out = upper(extractBefore(s,2)) + extractAfter(s,1);
end
