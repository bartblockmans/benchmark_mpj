"""
N-Body Galaxy Simulation in Python
==================================

This script simulates the gravitational dynamics of galaxies using an N-body approach.
It implements an all-pairs gravity calculation with Plummer softening for numerical stability.

Key Features:
- Multiple simulation scenarios: spiral galaxy collision, simple galaxy collision, 
  Plummer sphere, and random particle distribution
- Leapfrog integration scheme for accurate orbital dynamics
- Real-time visualization with particle trails and energy conservation plots
- Optional Numba JIT compilation for performance optimization
- Symmetric force calculation to ensure momentum conservation
- Import initial conditions from JSON files for reproducible results across languages

Physics:
- Gravitational force between all particle pairs (O(N²) complexity)
- Plummer softening to prevent infinite forces at close encounters
- Leapfrog integration: kick-drift-kick scheme for energy conservation
- Center-of-mass frame to eliminate overall system drift

Author: Bart Blockmans
Date: August 2025

Usage:
- Set IMPORT_IC = None to generate initial conditions using the current method
- Set IMPORT_IC = "filename.json" to import initial conditions from a JSON file
  (e.g., "nbody_ic_galaxy_spiral_N4000.json" generated by nbody_ic.py)
"""

# =============================================================================
# CONFIGURATION SECTION
# =============================================================================

# Visualization and Output Settings
VISUALIZE   = False           # Enable real-time plotting (set to False for headless runs)
STOREFINAL  = True            # Save initial and final snapshots to ./python/ directory
STOREALL    = True            # Save all snapshots to ./python/ directory
USE_NUMBA   = True            # Use Numba JIT compilation for physics loops (performance boost)
USE_SYM     = True            # Use symmetric i<j force loop for equal/opposite force updates

# Simulation Parameters
SCENARIO    = "galaxy_spiral" # Simulation scenario: "galaxy_spiral" | "galaxy" | "plummer" | "random"
N           = 4000            # Number of particles (increase to 10k+ for non-visual runs)
tEnd        = 3.0             # Total simulation time
dt          = 1e-3            # Time step (small step maintains galaxy stability)
G           = 1.0             # Gravitational constant (normalized units)
softening   = 1.5e-2          # Plummer softening parameter (prevents infinite forces)
SEED        = 17              # Random seed for reproducible results

# Initial Conditions Import
# Set to filename (e.g., "nbody_ic_galaxy_spiral_N4000.json") to import initial conditions
# Set to None to generate initial conditions using the current method
IMPORT_IC   = "nbody_ic_galaxy_spiral_N4000.json"             

# Visualization Parameters (only used when VISUALIZE=True or STOREFINAL=True)
TRAIL       = 1               # Number of time steps to show particle trails
POINT_SIZE  = 5               # Size of current-position markers
CMAP        = "viridis"       # Color map for speed-based particle coloring
DEPTH_CUE   = True            # Enable depth cueing (size/opacity based on z-coordinate)
BOUNDS      = 3.5             # Plot boundaries: x,y limits = ±BOUNDS
OUTPUT_STEP = 300             # Frequency of output visualization
FIGURE_NUM  = 1               # Sequential figure counter (separate from iteration number)

# =============================================================================
# IMPORTS AND ENVIRONMENT SETUP
# =============================================================================

import os
import numpy as np

# Create output directory for saved plots
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
OUT_DIR = os.path.join(BASE_DIR, "python")
os.makedirs(OUT_DIR, exist_ok=True)

# Set single-threaded environment for consistent benchmarking
# This ensures reproducible performance comparisons between languages
os.environ.setdefault("OMP_NUM_THREADS", "1")
os.environ.setdefault("OPENBLAS_NUM_THREADS", "1")
os.environ.setdefault("MKL_NUM_THREADS", "1")
os.environ.setdefault("VECLIB_MAXIMUM_THREADS", "1")
os.environ.setdefault("NUMEXPR_NUM_THREADS", "1")

# Use non-interactive matplotlib backend when not visualizing
# This prevents GUI windows from appearing during headless runs
if not VISUALIZE:
    import matplotlib
    matplotlib.use("Agg")
import matplotlib.pyplot as plt

# =============================================================================
# INITIAL CONDITIONS IMPORT FUNCTION
# =============================================================================

def import_initial_conditions(filename):
    """
    Import initial conditions from a JSON file generated by nbody_ic.py.
    
    Parameters:
    -----------
    filename : str
        Path to the JSON file containing initial conditions
    
    Returns:
    --------
    x, y, z, u, v, w, m : np.ndarray
        Particle positions, velocities, and masses
    G, softening : float
        Gravitational constant and softening parameter from the file
    
    Raises:
    -------
    FileNotFoundError : If the specified file doesn't exist
    ValueError : If the file format is invalid or incompatible
    """
    import json
    
    # Check if file exists
    if not os.path.exists(filename):
        raise FileNotFoundError(f"Initial conditions file not found: {filename}")
    
    try:
        # Read and parse JSON file
        with open(filename, 'r') as f:
            data = json.load(f)
        
        # Validate file format
        if 'format_version' not in data:
            raise ValueError("Invalid file format: missing 'format_version'")
        
        if 'metadata' not in data or 'particles' not in data:
            raise ValueError("Invalid file format: missing 'metadata' or 'particles' sections")
        
        # Extract metadata
        metadata = data['metadata']
        scenario = metadata.get('scenario', 'unknown')
        file_N = metadata.get('N', 0)
        file_G = metadata.get('Gconst', 1.0)
        file_softening = metadata.get('softening', 0.015)
        file_seed = metadata.get('seed', 0)
        
        # Extract particle data
        particles = data['particles']
        x = np.array(particles['positions']['x'], dtype=np.float32)
        y = np.array(particles['positions']['y'], dtype=np.float32)
        z = np.array(particles['positions']['z'], dtype=np.float32)
        u = np.array(particles['velocities']['u'], dtype=np.float32)
        v = np.array(particles['velocities']['v'], dtype=np.float32)
        w = np.array(particles['velocities']['w'], dtype=np.float32)
        m = np.array(particles['masses'], dtype=np.float32)
        
        # Validate data consistency
        if len(x) != file_N:
            raise ValueError(f"Particle count mismatch: expected {file_N}, got {len(x)}")
        
        if len(x) != len(y) or len(x) != len(z) or len(x) != len(u) or len(x) != len(v) or len(x) != len(w) or len(x) != len(m):
            raise ValueError("Inconsistent array lengths in particle data")
        
        # Print import information
        print(f"Imported initial conditions from: {filename}")
        print(f"  Scenario: {scenario}")
        print(f"  Particles: {file_N}")
        print(f"  G: {file_G}")
        print(f"  Softening: {file_softening}")
        print(f"  Seed: {file_seed}")
        print(f"  Generated by: {metadata.get('generated_by', 'unknown')}")
        print(f"  Timestamp: {metadata.get('timestamp', 'unknown')}")
        
        return x, y, z, u, v, w, m, file_G, file_softening
        
    except json.JSONDecodeError as e:
        raise ValueError(f"Invalid JSON format: {e}")
    except KeyError as e:
        raise ValueError(f"Missing required field in JSON: {e}")
    except Exception as e:
        raise ValueError(f"Error reading initial conditions file: {e}")

# =============================================================================
# NUMBA JIT COMPILATION SETUP
# =============================================================================

def _maybe_njit(*args, **kwargs):
    """
    Conditional Numba JIT decorator.
    
    If Numba is available, applies JIT compilation for performance.
    If not available, returns the original function unchanged.
    This allows the code to run with or without Numba installation.
    """
    try:
        from numba import njit
        return njit(*args, **kwargs)
    except Exception:
        def identity(f): return f
        return identity

# Apply Numba JIT if enabled, otherwise use identity function
nj = _maybe_njit(cache=True, fastmath=True) if USE_NUMBA else (lambda f: f)

# =============================================================================
# CORE PHYSICS FUNCTIONS
# =============================================================================

@nj
def compute_acc(x, y, z, m, G, eps, use_symmetry):
    """
    Compute gravitational acceleration for all particles.
    
    This is the computationally intensive O(N²) part of the simulation.
    Uses Plummer softening to prevent infinite forces at close encounters.
    
    Parameters:
    -----------
    x, y, z : np.ndarray[float32]
        Particle positions (1D arrays of length N)
    m : np.ndarray[float32]
        Particle masses (1D array of length N)
    G : float
        Gravitational constant
    eps : float
        Softening parameter (Plummer radius)
    use_symmetry : bool
        If True, use symmetric i<j loop for equal/opposite forces
        If False, compute all N² forces (slower but more explicit)
    
    Returns:
    --------
    ax, ay, az : np.ndarray[float32]
        Acceleration components for all particles
    """
    N = x.shape[0]
    ax = np.zeros(N, dtype=np.float32)
    ay = np.zeros(N, dtype=np.float32)
    az = np.zeros(N, dtype=np.float32)
    eps2 = np.float32(eps * eps)  # Softening parameter squared
    Gf   = np.float32(G)          # Gravitational constant as float32

    if use_symmetry:
        # Symmetric loop: compute force between each pair only once
        # This is more efficient and ensures exact momentum conservation
        for i in range(N - 1):
            xi, yi, zi = x[i], y[i], z[i]  # Position of particle i
            mi = m[i]                       # Mass of particle i
            
            for j in range(i + 1, N):
                # Vector from particle i to particle j
                dx = x[j] - xi
                dy = y[j] - yi
                dz = z[j] - zi
                
                # Distance squared with softening (prevents infinite forces)
                r2 = dx*dx + dy*dy + dz*dz + eps2
                
                # Compute 1/r and 1/r³ for force calculation
                inv_r = 1.0 / np.sqrt(r2)       # 1/r
                inv_r3 = inv_r / r2             # 1/r³
                
                # Force magnitude (scalar)
                s = Gf * inv_r3
                
                # Force vector components
                fx = s * dx
                fy = s * dy
                fz = s * dz
                
                # Apply equal and opposite forces (Newton's 3rd law)
                # Particle i feels force from particle j
                ax[i] += m[j] * fx
                ay[i] += m[j] * fy
                az[i] += m[j] * fz
                
                # Particle j feels equal and opposite force from particle i
                ax[j] -= mi * fx
                ay[j] -= mi * fy
                az[j] -= mi * fz
    else:
        # Non-symmetric loop: compute all N² forces explicitly
        # This is slower but more straightforward to understand
        for i in range(N):
            xi, yi, zi = x[i], y[i], z[i]
            aix = np.float32(0.0); aiy = np.float32(0.0); aiz = np.float32(0.0)
            
            for j in range(N):
                if j == i:  # Skip self-interaction
                    continue
                    
                # Vector from particle i to particle j
                dx = x[j] - xi
                dy = y[j] - yi
                dz = z[j] - zi
                
                # Distance squared with softening
                r2 = dx*dx + dy*dy + dz*dz + eps2
                inv_r = 1.0 / np.sqrt(r2)
                inv_r3 = inv_r / r2
                
                # Force on particle i due to particle j
                s = np.float32(G) * m[j] * inv_r3
                aix += s * dx
                aiy += s * dy
                aiz += s * dz
                
            ax[i] = aix; ay[i] = aiy; az[i] = aiz

    return ax, ay, az


@nj
def kinetic_energy(m, u, v, w):
    """
    Compute total kinetic energy of the system.
    
    KE = Σ(½ × m × v²) for all particles
    
    Parameters:
    -----------
    m, u, v, w : np.ndarray[float32]
        Particle masses and velocity components
    
    Returns:
    --------
    float : Total kinetic energy
    """
    ke = 0.0
    for i in range(m.shape[0]):
        # Velocity squared for particle i
        s = float(u[i])*float(u[i]) + float(v[i])*float(v[i]) + float(w[i])*float(w[i])
        ke += 0.5 * float(m[i]) * s
    return ke


@nj
def potential_energy(x, y, z, m, G, eps):
    """
    Compute total gravitational potential energy of the system.
    
    PE = -G × Σ(mᵢ × mⱼ / rᵢⱼ) for all particle pairs
    
    Parameters:
    -----------
    x, y, z, m : np.ndarray[float32]
        Particle positions and masses
    G : float
        Gravitational constant
    eps : float
        Softening parameter
    
    Returns:
    --------
    float : Total potential energy
    """
    N = x.shape[0]
    pe = 0.0
    eps2 = float(eps * eps)
    
    # Sum over all particle pairs (i < j to avoid double counting)
    for i in range(N - 1):
        xi, yi, zi = float(x[i]), float(y[i]), float(z[i])
        mi = float(m[i])
        
        for j in range(i + 1, N):
            # Distance between particles i and j
            dx = float(x[j]) - xi
            dy = float(y[j]) - yi
            dz = float(z[j]) - zi
            r = np.sqrt(dx*dx + dy*dy + dz*dz + eps2)
            
            # Gravitational potential energy between this pair
            pe += -float(G) * mi * float(m[j]) / r
            
    return pe

# =============================================================================
# INITIAL CONDITION GENERATORS
# =============================================================================

def disk(N, mass_total, *, Rmax=1.2, z_thick=0.1, v_rot=0.9, jitter=0.05, rng=None):
    """
    Generate initial conditions for a simple galaxy disk.
    
    Creates a disk with exponential-like density profile and circular orbits.
    This is useful for testing basic dynamics and as a starting point for more complex models.
    
    Parameters:
    -----------
    N : int
        Number of particles
    mass_total : float
        Total mass of the disk
    Rmax : float
        Maximum disk radius
    z_thick : float
        Disk thickness (z-coordinate range)
    v_rot : float
        Circular velocity scaling factor
    jitter : float
        Random velocity perturbation magnitude
    rng : np.random.Generator
        Random number generator
    
    Returns:
    --------
    x, y, z, u, v, w, m : np.ndarray[float32]
        Particle positions, velocities, and masses
    """
    if rng is None:
        # Use the global seeded RNG for consistency
        rng = np.random.default_rng(SEED)
    
    # Generate radial positions (more particles near center)
    R = Rmax * np.sqrt(rng.random(N, dtype=np.float32))
    
    # Generate random azimuthal angles
    theta = 2*np.pi * rng.random(N, dtype=np.float32)
    
    # Convert to Cartesian coordinates
    x = R * np.cos(theta)
    y = R * np.sin(theta)
    z = z_thick * 0.5 * rng.standard_normal(N, dtype=np.float32)

    # Circular velocity for orbital stability
    # v = v_rot × R / (0.3 + R) gives a realistic rotation curve
    vtan = v_rot * R / (0.3 + R)
    u = -vtan * np.sin(theta)  # x-velocity component
    v =  vtan * np.cos(theta)  # y-velocity component
    w = np.zeros_like(u)       # z-velocity component

    # Add random velocity perturbations for realistic dynamics
    u += jitter * rng.standard_normal(N, dtype=np.float32)
    v += jitter * rng.standard_normal(N, dtype=np.float32)
    w += 0.5*jitter * rng.standard_normal(N, dtype=np.float32)

    # Equal mass particles
    m = (mass_total / N) * np.ones(N, dtype=np.float32)
    return x, y, z, u, v, w, m


def _spiral_disk(
    N, mass_total,
    *, Rd=0.6, Rmax=1.8,
    m=2, pitch_deg=18.0, arm_amp=0.65,
    z_thick=0.08,
    v0=1.0, v_rise=0.35,
    nudge_r=0.05, nudge_t=0.02,
    jitter=0.03,
    rng=None, phi0=None
):
    """
    Generate initial conditions for a spiral galaxy disk.
    
    Creates an exponential disk with logarithmic spiral arm overdensities.
    This produces more realistic galaxy morphologies than simple disks.
    
    Parameters:
    -----------
    N : int
        Number of particles
    mass_total : float
        Total mass of the disk
    Rd : float
        Disk scale length (exponential falloff)
    Rmax : float
        Maximum disk radius
    m : int
        Number of spiral arms
    pitch_deg : float
        Pitch angle of spiral arms in degrees
    arm_amp : float
        Amplitude of spiral arm overdensity
    z_thick : float
        Disk thickness
    v0 : float
        Circular velocity at large radius
    v_rise : float
        Radius where velocity reaches v0
    nudge_r, nudge_t : float
        Radial and tangential velocity perturbations for spiral structure
    jitter : float
        Random velocity perturbation
    rng : np.random.Generator
        Random number generator
    phi0 : float
        Initial phase angle for spiral arms
    
    Returns:
    --------
    x, y, z, u, v, w, m : np.ndarray[float32]
        Particle positions, velocities, and masses
    """
    if rng is None:
        # Use the global seeded RNG for consistency
        rng = np.random.default_rng(SEED)
    if phi0 is None:
        phi0 = rng.uniform(0, 2*np.pi)

    # Generate radial positions using gamma distribution (more realistic than uniform)
    R = rng.gamma(shape=2.0, scale=Rd, size=N).astype(np.float32)
    
    # Ensure all particles are within Rmax
    while True:
        mask = R > Rmax
        if not np.any(mask):
            break
        R[mask] = rng.gamma(shape=2.0, scale=Rd, size=np.count_nonzero(mask)).astype(np.float32)

    # Spiral arm parameters
    k = 1.0 / np.tan(np.deg2rad(pitch_deg))  # Spiral pitch parameter
    
    # Generate azimuthal angles with spiral arm overdensity
    theta = np.empty(N, dtype=np.float32)
    filled = 0
    
    # Use rejection sampling to create spiral arm structure
    while filled < N:
        need = N - filled
        th_try = rng.uniform(0, 2*np.pi, size=need*2).astype(np.float32)
        R_rep  = np.repeat(R[filled:filled+need], 2)
        
        # Probability density for spiral arms
        p = 1.0 + arm_amp * np.cos(m * (th_try - k * np.log(R_rep + 1e-6) - phi0))
        uacc = rng.uniform(0, 1.0 + arm_amp, size=th_try.size).astype(np.float32)
        
        # Accept particles based on spiral arm probability
        keep = uacc < p
        n_keep = min(need, int(np.count_nonzero(keep)))
        theta[filled:filled+n_keep] = th_try[keep][:n_keep]
        filled += n_keep

    # Convert to Cartesian coordinates
    x = R * np.cos(theta)
    y = R * np.sin(theta)
    z = z_thick * 0.5 * rng.standard_normal(N, dtype=np.float32)

    # Velocity field with spiral structure
    v_circ = v0 * np.tanh(R / v_rise)  # Circular velocity
    phase = m * (theta - k * np.log(R + 1e-6) - phi0)  # Spiral phase
    
    # Velocity perturbations aligned with spiral arms
    v_r = nudge_r * v_circ * np.cos(phase)  # Radial velocity
    v_t = v_circ * (1.0 + nudge_t * np.sin(phase))  # Tangential velocity

    # Convert to Cartesian velocity components
    u = -v_t * np.sin(theta) + v_r * np.cos(theta)
    v =  v_t * np.cos(theta) + v_r * np.sin(theta)
    w =  0.5 * jitter * rng.standard_normal(N, dtype=np.float32)

    # Add random perturbations
    u += jitter * rng.standard_normal(N, dtype=np.float32)
    v += jitter * rng.standard_normal(N, dtype=np.float32)

    # Equal mass particles
    m = (mass_total / N) * np.ones(N, dtype=np.float32)
    return x, y, z, u, v, w, m


def init_ic(N, seed=17, scenario="galaxy"):
    """
    Generate initial conditions for the N-body simulation.
    
    Creates different particle distributions based on the selected scenario.
    All scenarios are set up in the center-of-mass frame for numerical stability.
    
    Parameters:
    -----------
    N : int
        Number of particles
    seed : int
        Random seed for reproducible results
    scenario : str
        Initial condition type: "galaxy_spiral", "galaxy", "plummer", or "random"
    
    Returns:
    --------
    x, y, z, u, v, w, m : np.ndarray[float32]
        Initial particle positions, velocities, and masses
    """
    rng = np.random.default_rng(seed)

    if scenario == "galaxy_spiral":
        # Two spiral galaxies on collision course
        N1 = N // 2
        N2 = N - N1
        
        # Different initial phases for the two galaxies
        phi1 = rng.uniform(0, 2*np.pi)
        phi2 = phi1 + np.pi / 3.0

        # Generate first spiral galaxy
        x1,y1,z1,u1,v1,w1,m1 = _spiral_disk(
            N1, mass_total=10.0, Rd=0.55, Rmax=1.7,
            m=2, pitch_deg=18.0, arm_amp=0.70, z_thick=0.07,
            v0=1.05, v_rise=0.32, nudge_r=0.06, nudge_t=0.03,
            jitter=0.025, rng=rng, phi0=phi1
        )
        
        # Generate second spiral galaxy
        x2,y2,z2,u2,v2,w2,m2 = _spiral_disk(
            N2, mass_total=10.0, Rd=0.55, Rmax=1.7,
            m=2, pitch_deg=18.0, arm_amp=0.70, z_thick=0.07,
            v0=1.05, v_rise=0.32, nudge_r=0.06, nudge_t=0.03,
            jitter=0.025, rng=rng, phi0=phi2
        )

        # Reverse velocity of second galaxy and offset positions
        u2, v2 = -u2, -v2  # Counter-rotating
        d   = 2.1           # Initial separation
        vcm = 0.45          # Center-of-mass velocity
        
        # Position and velocity offsets for collision
        x1 += -d; v1 += +vcm
        x2 += +d; v2 += -vcm

        # Combine the two galaxies
        x = np.concatenate([x1, x2]).astype(np.float32)
        y = np.concatenate([y1, y2]).astype(np.float32)
        z = np.concatenate([z1, z2]).astype(np.float32)
        u = np.concatenate([u1, u2]).astype(np.float32)
        v = np.concatenate([v1, v2]).astype(np.float32)
        w = np.concatenate([w1, w2]).astype(np.float32)
        m = np.concatenate([m1, m2]).astype(np.float32)

    elif scenario == "galaxy":
        # Two simple disk galaxies on collision course
        N1 = N // 2
        N2 = N - N1
        
        # Generate two identical disk galaxies
        x1,y1,z1,u1,v1,w1,m1 = disk(N1, 10.0, Rmax=1.1, z_thick=0.08, v_rot=1.0, jitter=0.05, rng=rng)
        x2,y2,z2,u2,v2,w2,m2 = disk(N2, 10.0, Rmax=1.1, z_thick=0.08, v_rot=1.0, jitter=0.05, rng=rng)
        
        # Counter-rotating galaxies
        u2, v2 = -u2, -v2
        d   = 2.0           # Initial separation
        vcm = 0.5           # Center-of-mass velocity
        
        # Position and velocity offsets
        x1 += -d; v1 += +vcm
        x2 += +d; v2 += -vcm

        # Combine the galaxies
        x = np.concatenate([x1,x2]).astype(np.float32)
        y = np.concatenate([y1,y2]).astype(np.float32)
        z = np.concatenate([z1,z2]).astype(np.float32)
        u = np.concatenate([u1,u2]).astype(np.float32)
        v = np.concatenate([v1,v2]).astype(np.float32)
        w = np.concatenate([w1,w2]).astype(np.float32)
        m = np.concatenate([m1,m2]).astype(np.float32)

    elif scenario == "plummer":
        # Plummer sphere: a realistic model for globular clusters
        a = 0.5  # Scale radius
        
        # Generate positions using Plummer distribution
        u = rng.random(N, dtype=np.float32)
        r = a / np.sqrt(u**(-2/3) - 1.0 + 1e-6)  # Radial distribution
        
        # Random spherical angles
        phi = 2*np.pi * rng.random(N, dtype=np.float32)      # Azimuthal
        cos_t = 2*rng.random(N, dtype=np.float32)-1          # Cosine of polar
        sin_t = np.sqrt(1 - cos_t**2)                        # Sine of polar
        
        # Convert to Cartesian coordinates
        x = r * sin_t * np.cos(phi)
        y = r * sin_t * np.sin(phi)
        z = r * cos_t
        
        # Small random velocities
        u = 0.02 * rng.standard_normal(N, dtype=np.float32)
        v = 0.02 * rng.standard_normal(N, dtype=np.float32)
        w = 0.02 * rng.standard_normal(N, dtype=np.float32)
        m = (20.0 / N) * np.ones(N, dtype=np.float32)

    else:  # "random"
        # Random particle distribution (useful for testing)
        x = rng.standard_normal(N, dtype=np.float32)
        y = rng.standard_normal(N, dtype=np.float32)
        z = rng.standard_normal(N, dtype=np.float32)
        u = rng.standard_normal(N, dtype=np.float32)
        v = rng.standard_normal(N, dtype=np.float32)
        w = rng.standard_normal(N, dtype=np.float32)
        m = (20.0 / N) * np.ones(N, dtype=np.float32)

    # Transform to center-of-mass frame for numerical stability
    # This prevents the entire system from drifting
    mu = np.mean(m * u); mv = np.mean(m * v); mw = np.mean(m * w)
    mbar = np.mean(m)
    u -= mu / mbar; v -= mv / mbar; w -= mw / mbar
    
    return x, y, z, u, v, w, m

# =============================================================================
# VISUALIZATION HELPER FUNCTIONS
# =============================================================================

def _style_axes_dark(ax):
    """Apply dark theme styling to a matplotlib axis."""
    ax.set_facecolor("black")
    for spine in ax.spines.values():
        spine.set_color("#888888")
    ax.tick_params(colors="#dddddd")
    ax.xaxis.label.set_color("#ffffff")
    ax.yaxis.label.set_color("#ffffff")
    ax.title.set_color("#ffffff")


def _style_axes_light(ax):
    """Apply light theme styling to a matplotlib axis."""
    ax.set_facecolor("white")
    for spine in ax.spines.values():
        spine.set_color("#333333")
    ax.tick_params(colors="#111111")
    ax.xaxis.label.set_color("#111111")
    ax.yaxis.label.set_color("#111111")
    ax.title.set_color("#111111")


def _setup_figure():
    """
    Create and configure the main visualization figure.
    
    Sets up a 3-panel layout: positions (top 2/3) and energy (bottom 1/3).
    
    Returns:
    --------
    fig : matplotlib.figure.Figure
        The main figure
    ax_pos : matplotlib.axes.Axes
        Axes for particle positions (dark theme)
    ax_eng : matplotlib.axes.Axes
        Axes for energy plots (light theme)
    """
    fig = plt.figure(figsize=(6.5, 7.5), dpi=110)
    grid = plt.GridSpec(3, 1, wspace=0.0, hspace=0.32, height_ratios=[1.0, 1.0, 0.9])
    ax_pos = plt.subplot(grid[0:2, 0])   # Dark theme for positions
    ax_eng = plt.subplot(grid[2, 0])     # Light theme for energy
    _style_axes_dark(ax_pos)
    _style_axes_light(ax_eng)
    return fig, ax_pos, ax_eng


def _render_snapshot(path, x, y, z, u, v, w, title_str, times=None, KE_save=None, PE_save=None):
    """
    Save a two-panel snapshot matching the live visualization.
    
    Creates a standalone figure with the same layout as the live visualization:
    - Top panel: Particle positions with dark theme
    - Bottom panel: Energy evolution with light theme
    
    Parameters:
    -----------
    path : str
        File path for saving the image
    x, y, z, u, v, w : np.ndarray
        Particle positions and velocities
    title_str : str
        Title for the plot
    times : np.ndarray, optional
        Time points for energy history
    KE_save : np.ndarray, optional
        Kinetic energy history
    PE_save : np.ndarray, optional
        Potential energy history
    """
    if times is not None and KE_save is not None and PE_save is not None:
        # Two-panel layout matching live visualization
        fig = plt.figure(figsize=(6.8, 8.2), dpi=120)
        gs = fig.add_gridspec(3, 1, hspace=0.3)
        
        # Upper 2 panels merged for positions (dark theme)
        ax_pos = fig.add_subplot(gs[:2, 0])
        _style_axes_dark(ax_pos)
        
        # Color particles by speed
        speed = np.sqrt(u*u + v*v + w*w)
        smin, smax = np.percentile(speed, [5, 95])
        smax = max(smax, smin + 1e-6)
        cmap = plt.get_cmap(CMAP)
        color = cmap(np.clip((speed - smin) / (smax - smin), 0, 1))

        # Apply depth cueing if enabled
        if DEPTH_CUE:
            zmin, zmax = np.percentile(z, [5, 95])
            zrange = max(zmax - zmin, 1e-3)
            depth = np.clip((z - zmin) / zrange, 0, 1)
            sizes = POINT_SIZE * (0.6 + 0.8*(1.0 - depth))  # Nearer = bigger
            color[:, 3] = 0.6 + 0.4*(1.0 - depth)           # Nearer = more opaque
        else:
            sizes = POINT_SIZE * np.ones_like(x)

        # Plot particles
        ax_pos.scatter(x, y, s=sizes, c=color, linewidths=0)
        ax_pos.set_aspect("equal", "box")
        ax_pos.set_xlim(-BOUNDS, BOUNDS)
        ax_pos.set_ylim(-BOUNDS, BOUNDS)
        ax_pos.set_title(title_str)
        
        # Bottom panel for energies (light theme)
        ax_eng = fig.add_subplot(gs[2, 0])
        _style_axes_light(ax_eng)
        
        # Plot energy evolution
        ax_eng.plot(times, KE_save, color="#cc3333", lw=1.1, label='KE')
        ax_eng.plot(times, PE_save, color="#3366cc", lw=1.1, label='PE')
        ax_eng.plot(times, (KE_save + PE_save), color="#222222", lw=1.2, label='Etot')
        ax_eng.set_xlim(0, max(times))
        ax_eng.set_xlabel("Time [-]")
        ax_eng.set_ylabel("Energy [-]")
        
        # Add legend
        leg = ax_eng.legend(loc="upper right", fontsize=8,
                            facecolor="#f6f6f6", edgecolor="#999999")
        for txt in leg.get_texts():
            txt.set_color("#111111")
    else:
        # Single panel for initial snapshot (no energy data yet)
        fig, ax = plt.subplots(figsize=(7, 7), dpi=120)
        _style_axes_dark(ax)

        # Color particles by speed
        speed = np.sqrt(u*u + v*v + w*w)
        smin, smax = np.percentile(speed, [5, 95])
        smax = max(smax, smin + 1e-6)
        cmap = plt.get_cmap(CMAP)
        color = cmap(np.clip((speed - smin) / (smax - smin), 0, 1))

        # Apply depth cueing if enabled
        if DEPTH_CUE:
            zmin, zmax = np.percentile(z, [5, 95])
            zrange = max(zmax - zmin, 1e-3)
            depth = np.clip((z - zmin) / zrange, 0, 1)
            sizes = POINT_SIZE * (0.6 + 0.8*(1.0 - depth))  # Nearer = bigger
            color[:, 3] = 0.6 + 0.4*(1.0 - depth)           # Nearer = more opaque
        else:
            sizes = POINT_SIZE * np.ones_like(x)

        # Plot particles
        ax.scatter(x, y, s=sizes, c=color, linewidths=0)
        ax.set_aspect("equal", "box")
        ax.set_xlim(-BOUNDS, BOUNDS)
        ax.set_ylim(-BOUNDS, BOUNDS)
        ax.set_title(title_str)
        ax.set_xlabel("x"); ax.set_ylabel("y")
    
    # Save and close
    plt.savefig(path, dpi=220)
    plt.close(fig)


def render_animation_frame(path, x, y, z, u, v, w, title_str=""):
    """
    Save a clean animation frame without ticks or labels.
    
    Creates a clean image suitable for animation with:
    - Black background (matching the galaxy visualization)
    - No axis ticks, tick labels, or axis labels
    - Just the particle positions with speed-based coloring
    - Consistent with the main visualization style
    
    Parameters:
    -----------
    path : str
        File path for saving the image
    x, y, z, u, v, w : np.ndarray
        Particle positions and velocities
    title_str : str
        Title for the plot (usually empty for animation frames)
    """
    # Create figure with black background (matching galaxy panel)
    fig, ax = plt.subplots(figsize=(7, 7), dpi=120)
    
    # Color particles by speed
    speed = np.sqrt(u*u + v*v + w*w)
    smin, smax = np.percentile(speed, [5, 95])
    smax = max(smax, smin + 1e-6)
    cmap = plt.get_cmap(CMAP)
    color = cmap(np.clip((speed - smin) / (smax - smin), 0, 1))

    # Apply depth cueing if enabled
    if DEPTH_CUE:
        zmin, zmax = np.percentile(z, [5, 95])
        zrange = max(zmax - zmin, 1e-3)
        depth = np.clip((z - zmin) / zrange, 0, 1)
        sizes = POINT_SIZE * (0.6 + 0.8*(1.0 - depth))  # Nearer = bigger
        color[:, 3] = 0.6 + 0.4*(1.0 - depth)           # Nearer = more opaque
    else:
        sizes = POINT_SIZE * np.ones_like(x)

    # Plot particles
    ax.scatter(x, y, s=sizes, c=color, linewidths=0)
    
    # Configure plot appearance for clean animation frame
    ax.set_aspect("equal", "box")
    ax.set_xlim(-BOUNDS, BOUNDS)
    ax.set_ylim(-BOUNDS, BOUNDS)
    
    # Remove all ticks, labels, and grid for clean animation
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_xlabel("")
    ax.set_ylabel("")
    ax.set_title("")
    
    # Ensure black background
    ax.set_facecolor("black")
    fig.patch.set_facecolor("black")
    
    # Remove spines for completely clean look
    for spine in ax.spines.values():
        spine.set_visible(False)
    
    # Save and close
    plt.savefig(path, dpi=220, bbox_inches='tight', facecolor='black')
    plt.close(fig)

# =============================================================================
# MAIN SIMULATION FUNCTION
# =============================================================================

def main():
    """
    Main simulation function.
    
    Implements the leapfrog integration scheme:
    1. Half-kick: update velocities by half a time step
    2. Drift: update positions by a full time step
    3. Update accelerations (forces)
    4. Half-kick: complete velocity update
    
    This scheme conserves energy better than simple Euler integration.
    """
    global FIGURE_NUM  # Declare FIGURE_NUM as global to modify it within the function
    
    # Initialize particle system
    if IMPORT_IC is not None:
        # Import initial conditions from file
        print(f"Importing initial conditions from: {IMPORT_IC}")
        try:
            x, y, z, u, v, w, m, file_G, file_softening = import_initial_conditions(IMPORT_IC)
            
            # Use parameters from the imported file
            G_actual = file_G
            softening_actual = file_softening
            N_actual = len(x)
            
            print(f"Using imported parameters: G={G_actual}, softening={softening_actual}, N={N_actual}")
            
            # Use imported N for the simulation
            if N_actual != N:
                print(f"Warning: Imported N={N_actual} differs from configured N={N}")
                print(f"Using imported value: N={N_actual}")
            
        except Exception as e:
            print(f"Error importing initial conditions: {e}")
            print("Falling back to generated initial conditions...")
            x, y, z, u, v, w, m = init_ic(N, SEED, SCENARIO)
            G_actual = G
            softening_actual = softening
            N_actual = N
    else:
        # Generate initial conditions using current method
        print(f"Initializing {SCENARIO} scenario with {N} particles...")
        x, y, z, u, v, w, m = init_ic(N, SEED, SCENARIO)
        G_actual = G
        softening_actual = softening
        N_actual = N
    
    # Compute initial accelerations
    print("Computing initial forces...")
    ax, ay, az = compute_acc(x, y, z, m, G_actual, softening_actual, USE_SYM)

    # Save initial snapshot if requested
    if STOREFINAL:
        print("Saving initial snapshot...")
        _render_snapshot(
            os.path.join(OUT_DIR, f"nbody_{SCENARIO}_initial_python.png"),
            x, y, z, u, v, w,
            f"{SCENARIO.capitalize()} – initial"
        )

    # Time integration setup
    Nt = int(np.ceil(tEnd / dt))
    print(f"Running simulation for {Nt} time steps (dt={dt}, tEnd={tEnd})...")

    if VISUALIZE:
        # Setup real-time visualization
        print("Setting up visualization...")
        fig, ax_pos, ax_eng = _setup_figure()
        
        # Trail buffers for particle history
        trail_x = np.zeros((TRAIL, N_actual), dtype=np.float32)
        trail_y = np.zeros((TRAIL, N_actual), dtype=np.float32)
        trail_len = 0
        trail_idx = 0

        # Energy tracking arrays
        times = np.empty(Nt + 1, dtype=np.float64)
        KE_save = np.empty(Nt + 1, dtype=np.float64)
        PE_save = np.empty(Nt + 1, dtype=np.float64)

        # Initial energy values
        KE_save[0] = kinetic_energy(m, u, v, w)
        PE_save[0] = potential_energy(x, y, z, m, G_actual, softening_actual)
        times[0]   = 0.0

        cmap = plt.get_cmap(CMAP)

    # Main time integration loop
    t = 0.0
    for it in range(1, Nt + 1):
        # LEAPFROG INTEGRATION SCHEME
        
        # Step 1: Half-kick (update velocities by half a time step)
        u += 0.5 * dt * ax
        v += 0.5 * dt * ay
        w += 0.5 * dt * az

        # Step 2: Drift (update positions by full time step)
        x += dt * u
        y += dt * v
        z += dt * w

        # Step 3: Update accelerations (forces)
        ax, ay, az = compute_acc(x, y, z, m, G_actual, softening_actual, USE_SYM)

        # Step 4: Complete the kick (update velocities by remaining half time step)
        u += 0.5 * dt * ax
        v += 0.5 * dt * ay
        w += 0.5 * dt * az

        t += dt

        # Periodic image saving for animation (only when STOREALL=True)
        if STOREALL and it % OUTPUT_STEP == 0:
            # Create clean animation frame (no ticks, no labels, just particles)
            render_animation_frame(
                os.path.join(OUT_DIR, f"nbody_galaxy_spiral_{FIGURE_NUM:04d}_python.png"),
                x, y, z, u, v, w, title_str=""
            )
            FIGURE_NUM += 1  # Increment figure counter

        # Real-time visualization updates
        if VISUALIZE:
            # Track energy conservation
            KE_save[it] = kinetic_energy(m, u, v, w)
            PE_save[it] = potential_energy(x, y, z, m, G_actual, softening_actual)
            times[it]   = t

            # Update particle trails
            trail_x[trail_idx, :] = x
            trail_y[trail_idx, :] = y
            trail_idx = (trail_idx + 1) % TRAIL
            trail_len = min(trail_len + 1, TRAIL)
            idxs = (np.arange(trail_len) + (trail_idx - trail_len)) % TRAIL
            xx = trail_x[idxs, :]
            yy = trail_y[idxs, :]

            # Color particles by speed
            speed = np.sqrt(u*u + v*v + w*w)
            smin, smax = np.percentile(speed, [5, 95])
            smax = max(smax, smin + 1e-6)
            color = cmap(np.clip((speed - smin) / (smax - smin), 0, 1))

            # Apply depth cueing
            if DEPTH_CUE:
                zmin, zmax = np.percentile(z, [5, 95])
                zrange = max(zmax - zmin, 1e-3)
                depth = np.clip((z - zmin) / zrange, 0, 1)
                sizes = POINT_SIZE * (0.6 + 0.8*(1.0 - depth))   # Nearer = bigger
                color[:, 3] = 0.6 + 0.4*(1.0 - depth)            # Nearer = more opaque
            else:
                sizes = POINT_SIZE * np.ones_like(x)

            # Update positions panel (dark theme)
            ax_pos.cla()
            
            # Draw particle trails
            if trail_len > 1:
                alphas = np.linspace(0.08, 0.35, trail_len)
                sizes_trail = np.linspace(0.5*POINT_SIZE, 0.9*POINT_SIZE, trail_len)
                for xxk, yyk, ak, sk in zip(xx, yy, alphas, sizes_trail):
                    ax_pos.scatter(xxk, yyk, s=sk, color=(0.7, 0.7, 1.0, ak), linewidths=0)

            # Draw current particle positions
            ax_pos.scatter(x, y, s=sizes, c=color, linewidths=0)
            ax_pos.set_aspect("equal", "box")
            ax_pos.set_xlim(-BOUNDS, BOUNDS)
            ax_pos.set_ylim(-BOUNDS, BOUNDS)
            ax_pos.set_title(f"{SCENARIO.capitalize()}  (N={N_actual})   t = {t:.2f}")
            _style_axes_dark(ax_pos)  # Re-apply styling after clearing

            # Update energy panel (light theme)
            ax_eng.cla()
            ax_eng.plot(times[:it+1], KE_save[:it+1], color="#cc3333", lw=1.1, label='KE')
            ax_eng.plot(times[:it+1], PE_save[:it+1], color="#3366cc", lw=1.1, label='PE')
            ax_eng.plot(times[:it+1], (KE_save[:it+1] + PE_save[:it+1]),
                        color="#222222", lw=1.2, label='Etot')
            ax_eng.set_xlim(0, tEnd)
            ax_eng.set_xlabel("time")
            ax_eng.set_ylabel("energy")
            _style_axes_light(ax_eng)  # Keep energy panel readable
            
            # Add legend
            leg = ax_eng.legend(loc="upper right", fontsize=8,
                                facecolor="#f6f6f6", edgecolor="#999999")
            for txt in leg.get_texts():
                txt.set_color("#111111")

            # Update display
            plt.pause(0.001)

    # Save final snapshot if requested
    if STOREFINAL:
        print("Saving final snapshot...")
        if VISUALIZE:
            # Save the existing live visualization figure (which already has correct styling)
            # This preserves the black background for galaxies panel and white background for energy panel
            plt.savefig(os.path.join(OUT_DIR, f"nbody_{SCENARIO}_final_python.png"), dpi=220)
        else:
            # No energy data available when VISUALIZE=false
            # Create a simple snapshot with just particle positions
            _render_snapshot(
                os.path.join(OUT_DIR, f"nbody_{SCENARIO}_final_python.png"),
                x, y, z, u, v, w,
                f"{SCENARIO.capitalize()} – final  (t = {t:.2f})"
            )

    # Note: Final visualization is already saved above when VISUALIZE=true
    # No need to save the live visualization figure separately
    
    print("Simulation complete!")

# =============================================================================
# SCRIPT ENTRY POINT
# =============================================================================

if __name__ == "__main__":
    main()
