"""
N-Body Galaxy Simulation in Python (OPTIMIZED VERSION)
=====================================================

This script simulates the gravitational dynamics of galaxies using an N-body approach.
It implements an all-pairs gravity calculation with Plummer softening for numerical stability.

This is the OPTIMIZED version with the following performance improvements:
- In-place force computation (no per-step array allocations)
- Preallocated acceleration arrays with efficient clearing
- Float32 consistency throughout for optimal performance
- Kernel warm-up to exclude compilation time from performance measurements
- Separate specialized kernels for symmetric/non-symmetric force computation
- NumPy vectorized integration (O(N)) + Numba JIT force computation (O(N²))

Key Features:
- Multiple simulation scenarios: spiral galaxy collision, simple galaxy collision, 
  Plummer sphere, and random particle distribution
- Leapfrog integration scheme for accurate orbital dynamics
- Real-time visualization with particle trails and energy conservation plots
- Optional Numba JIT compilation for performance optimization
- Symmetric force calculation to ensure momentum conservation
- Import initial conditions from JSON files for reproducible results across languages

Physics:
- Gravitational force between all particle pairs (O(N²) complexity)
- Plummer softening to prevent infinite forces at close encounters
- Leapfrog integration: kick-drift-kick scheme for energy conservation
- Center-of-mass frame to eliminate overall system drift

Performance Notes:
- This optimized version maintains fair comparison with other language implementations
- All optimizations are language-specific (no external libraries beyond Numba)
- Blocked computation is automatically disabled for small particle counts
- Kernel warm-up ensures compilation time is not included in timing measurements

Author: Bart Blockmans
Date: August 2025

Usage:
- Set IMPORT_IC = None to generate initial conditions using the current method
- Set IMPORT_IC = "filename.json" to import initial conditions from a JSON file
  (e.g., "nbody_ic_galaxy_spiral_N4000.json" generated by nbody_ic.py)
"""

# =============================================================================
# CONFIGURATION SECTION
# =============================================================================

# BENCHMARKING OPTIMIZATION SETTINGS (ENABLED BY DEFAULT)
# ======================================================
# This script is automatically configured for maximum performance:
# - USE_NUMBA = True: JIT compilation enabled for physics loops
# - USE_SYM = True: Symmetric force computation for momentum conservation
# - USE_BLOCKED = True: Cache blocking for better memory locality
# - VISUALIZE = False: Headless mode for maximum speed
# - Single-threaded environment variables set automatically
#
# No special command-line arguments needed - runs at full performance by default!

# Visualization and Output Settings
VISUALIZE   = False           # Enable real-time plotting (set to False for headless runs)
STOREFINAL  = False           # Save initial and final snapshots to ./python/ directory
USE_NUMBA   = True            # Use Numba JIT compilation for physics loops (performance boost)
USE_SYM     = True            # Use symmetric i<j force loop for equal/opposite force updates

# Performance Optimization Settings
USE_BLOCKED = False           # Use blocked force computation for better cache utilization (N ≳ few thousand)
BLOCK_SIZE  = 128             # Block size for cache-friendly force computation (64-256 typically optimal)

# Simulation Parameters
SCENARIO    = "galaxy_spiral" # Simulation scenario: "galaxy_spiral" | "galaxy" | "plummer" | "random"
N           = 4000            # Number of particles (increase to 10k+ for non-visual runs)
tEnd        = 1.0             # Total simulation time
dt          = 1e-3            # Time step (small step maintains galaxy stability)
G           = 1.0             # Gravitational constant (normalized units)
softening   = 1.5e-2          # Plummer softening parameter (prevents infinite forces)
SEED        = 17              # Random seed for reproducible results

# Initial Conditions Import
# Set to filename (e.g., "nbody_ic_galaxy_spiral_N4000.json") to import initial conditions
# Set to None to generate initial conditions using the current method
IMPORT_IC   = "nbody_ic_galaxy_spiral_N4000.json"  

# Visualization Parameters (only used when VISUALIZE=True or STOREFINAL=True)
TRAIL       = 1               # Number of time steps to show particle trails
POINT_SIZE  = 5               # Size of current-position markers
CMAP        = "viridis"       # Color map for speed-based particle coloring
DEPTH_CUE   = True            # Enable depth cueing (size/opacity based on z-coordinate)
BOUNDS      = 3.5             # Plot boundaries: x,y limits = ±BOUNDS

# =============================================================================
# IMPORTS AND ENVIRONMENT SETUP
# =============================================================================

import os
import numpy as np

# Create output directory for saved plots
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
OUT_DIR = os.path.join(BASE_DIR, "python")
os.makedirs(OUT_DIR, exist_ok=True)

# Set single-threaded environment for consistent benchmarking
# This ensures reproducible performance comparisons between languages
os.environ.setdefault("OMP_NUM_THREADS", "1")
os.environ.setdefault("OPENBLAS_NUM_THREADS", "1")
os.environ.setdefault("MKL_NUM_THREADS", "1")
os.environ.setdefault("VECLIB_MAXIMUM_THREADS", "1")
os.environ.setdefault("NUMEXPR_NUM_THREADS", "1")

# Use non-interactive matplotlib backend when not visualizing
# This prevents GUI windows from appearing during headless runs
if not VISUALIZE:
    import matplotlib
    matplotlib.use("Agg")
import matplotlib.pyplot as plt

# =============================================================================
# INITIAL CONDITIONS IMPORT FUNCTION
# =============================================================================

def import_initial_conditions(filename):
    """
    Import initial conditions from a JSON file generated by nbody_ic.py.
    
    Parameters:
    -----------
    filename : str
        Path to the JSON file containing initial conditions
    
    Returns:
    --------
    x, y, z, u, v, w, m : np.ndarray
        Particle positions, velocities, and masses
    G, softening : float
        Gravitational constant and softening parameter from the file
    
    Raises:
    -------
    FileNotFoundError : If the specified file doesn't exist
    ValueError : If the file format is invalid or incompatible
    """
    import json
    
    # Check if file exists
    if not os.path.exists(filename):
        raise FileNotFoundError(f"Initial conditions file not found: {filename}")
    
    try:
        # Read and parse JSON file
        with open(filename, 'r') as f:
            data = json.load(f)
        
        # Validate file format
        if 'format_version' not in data:
            raise ValueError("Invalid file format: missing 'format_version'")
        
        if 'metadata' not in data or 'particles' not in data:
            raise ValueError("Invalid file format: missing 'metadata' or 'particles' sections")
        
        # Extract metadata
        metadata = data['metadata']
        scenario = metadata.get('scenario', 'unknown')
        file_N = metadata.get('N', 0)
        file_G = metadata.get('Gconst', 1.0)
        file_softening = metadata.get('softening', 0.015)
        file_seed = metadata.get('seed', 0)
        
        # Extract particle data
        particles = data['particles']
        x = np.array(particles['positions']['x'], dtype=np.float32)
        y = np.array(particles['positions']['y'], dtype=np.float32)
        z = np.array(particles['positions']['z'], dtype=np.float32)
        u = np.array(particles['velocities']['u'], dtype=np.float32)
        v = np.array(particles['velocities']['v'], dtype=np.float32)
        w = np.array(particles['velocities']['w'], dtype=np.float32)
        m = np.array(particles['masses'], dtype=np.float32)
        
        # Validate data consistency
        if len(x) != file_N:
            raise ValueError(f"Particle count mismatch: expected {file_N}, got {len(x)}")
        
        if len(x) != len(y) or len(x) != len(z) or len(x) != len(u) or len(x) != len(v) or len(x) != len(w) or len(x) != len(m):
            raise ValueError("Inconsistent array lengths in particle data")
        
        # Print import information
        print(f"Imported initial conditions from: {filename}")
        print(f"  Scenario: {scenario}")
        print(f"  Particles: {file_N}")
        print(f"  G: {file_G}")
        print(f"  Softening: {file_softening}")
        print(f"  Seed: {file_seed}")
        print(f"  Generated by: {metadata.get('generated_by', 'unknown')}")
        print(f"  Timestamp: {metadata.get('timestamp', 'unknown')}")
        
        return x, y, z, u, v, w, m, file_G, file_softening
        
    except json.JSONDecodeError as e:
        raise ValueError(f"Invalid JSON format: {e}")
    except KeyError as e:
        raise ValueError(f"Missing required field in JSON: {e}")
    except Exception as e:
        raise ValueError(f"Error reading initial conditions file: {e}")

# =============================================================================
# NUMBA JIT COMPILATION SETUP
# =============================================================================

def _maybe_njit(*args, **kwargs):
    """
    Conditional Numba JIT decorator.
    
    If Numba is available, applies JIT compilation for performance.
    If not available, returns the original function unchanged.
    This allows the code to run with or without Numba installation.
    """
    try:
        from numba import njit
        return njit(*args, **kwargs)
    except Exception:
        def identity(f): return f
        return identity

# Apply Numba JIT if enabled, otherwise use identity function
nj = _maybe_njit(cache=True, fastmath=True) if USE_NUMBA else (lambda f: f)

# =============================================================================
# CORE PHYSICS FUNCTIONS (OPTIMIZED)
# =============================================================================

@nj
def compute_acc_sym_inplace(ax, ay, az, x, y, z, m, G, eps2):
    """
    Compute gravitational acceleration for all particles in-place (symmetric version).
    
    This is the computationally intensive O(N²) part of the simulation.
    Uses Plummer softening to prevent infinite forces at close encounters.
    Optimized for symmetric i<j force loop with in-place accumulation.
    
    Parameters:
    -----------
    ax, ay, az : np.ndarray[float32]
        Acceleration component arrays (modified in-place)
    x, y, z : np.ndarray[float32]
        Particle positions (1D arrays of length N)
    m : np.ndarray[float32]
        Particle masses (1D array of length N)
    G : float32
        Gravitational constant
    eps2 : float32
        Softening parameter squared
    
    Note: Arrays must be contiguous float32 for optimal performance
    """
    n = x.shape[0]
    
    # Use same approach as baseline for consistent performance
    ax.fill(0.0); ay.fill(0.0); az.fill(0.0)
    
    # Symmetric loop: compute force between each pair only once
    # This is more efficient and ensures exact momentum conservation
    for i in range(n - 1):
        xi = x[i]; yi = y[i]; zi = z[i]; mi = m[i]  # Position and mass of particle i
        
        for j in range(i + 1, n):
            # Vector from particle i to particle j
            dx = x[j] - xi
            dy = y[j] - yi
            dz = z[j] - zi
            
            # Distance squared with softening (prevents infinite forces)
            r2 = dx*dx + dy*dy + dz*dz + eps2
            
            # Compute 1/r and 1/r³ for force calculation
            inv_r  = 1.0 / np.sqrt(r2)       # 1/r
            inv_r3 = inv_r / r2               # 1/r³
            
            # Force magnitude (scalar)
            s = G * inv_r3
            
            # Force vector components
            fx = s * dx; fy = s * dy; fz = s * dz
            
            # Apply equal and opposite forces (Newton's 3rd law)
            # Particle i feels force from particle j
            ax[i] += m[j] * fx; ay[i] += m[j] * fy; az[i] += m[j] * fz
            # Particle j feels equal and opposite force from particle i
            ax[j] -= mi   * fx; ay[j] -= mi   * fy; az[j] -= mi   * fz
    
    return ax, ay, az


@nj
def compute_acc_full_inplace(ax, ay, az, x, y, z, m, G, eps2):
    """
    Compute gravitational acceleration for all particles in-place (full version).
    
    Non-symmetric loop: compute all N² forces explicitly.
    This is slower but more straightforward to understand.
    
    Parameters:
    -----------
    ax, ay, az : np.ndarray[float32]
        Acceleration component arrays (modified in-place)
    x, y, z : np.ndarray[float32]
        Particle positions (1D arrays of length N)
    m : np.ndarray[float32]
        Particle masses (1D array of length N)
    G : float32
        Gravitational constant
    eps2 : float32
        Softening parameter squared
    """
    n = x.shape[0]
    
    # Clear acceleration arrays efficiently
    ax.fill(0.0); ay.fill(0.0); az.fill(0.0)
    
    # Non-symmetric loop: compute all N² forces explicitly
    for i in range(n):
        xi = x[i]; yi = y[i]; zi = z[i]
        aix = 0.0; aiy = 0.0; aiz = 0.0  # Accumulate accelerations for particle i
        
        for j in range(n):
            if j == i:  # Skip self-interaction
                continue
                
            # Vector from particle i to particle j
            dx = x[j] - xi
            dy = y[j] - yi
            dz = z[j] - zi
            
            # Distance squared with softening
            r2 = dx*dx + dy*dy + dz*dz + eps2
            inv_r = 1.0 / np.sqrt(r2)
            inv_r3 = inv_r / r2
            
            # Force on particle i due to particle j
            s = G * m[j] * inv_r3
            aix += s * dx; aiy += s * dy; aiz += s * dz
            
        # Store accumulated accelerations
        ax[i] = aix; ay[i] = aiy; az[i] = aiz


@nj
def compute_acc_sym_blocked(ax, ay, az, x, y, z, m, G, eps2, B=128):
    """
    Compute gravitational acceleration with blocked loops for better cache utilization.
    
    For N ≳ a few thousand, blocking improves L1/L2 cache reuse by 10-30%.
    This is the most optimized version for large particle counts.
    
    Parameters:
    -----------
    ax, ay, az : np.ndarray[float32]
        Acceleration component arrays (modified in-place)
    x, y, z : np.ndarray[float32]
        Particle positions (1D arrays of length N)
    m : np.ndarray[float32]
        Particle masses (1D array of length N)
    G : float32
        Gravitational constant
    eps2 : float32
        Softening parameter squared
    B : int
        Block size (64-256 typically optimal)
    """
    n = x.shape[0]
    
    # Clear acceleration arrays efficiently
    ax.fill(0.0); ay.fill(0.0); az.fill(0.0)
    
    # Two-level blocking for cache-friendly memory access
    for ib in range(0, n-1, B):
        iend = min(n-1, ib+B-1)
        for jb in range(ib+1, n, B):
            jend = min(n, jb+B)
            
            for i in range(ib, iend+1):
                xi = x[i]; yi = y[i]; zi = z[i]; mi = m[i]
                
                # Start j at max(i+1, jb) to keep symmetry correct inside a block
                j0 = jb if jb > i else i+1
                
                for j in range(j0, jend):
                    # Vector from particle i to particle j
                    dx = x[j] - xi
                    dy = y[j] - yi
                    dz = z[j] - zi
                    
                    # Distance squared with softening
                    r2 = dx*dx + dy*dy + dz*dz + eps2
                    inv_r = 1.0 / np.sqrt(r2)
                    inv_r3 = inv_r / r2
                    
                    # Force magnitude and components
                    s = G * inv_r3
                    fx = s * dx; fy = s * dy; fz = s * dz
                    
                    # Apply equal and opposite forces
                    ax[i] += m[j] * fx; ay[i] += m[j] * fy; az[i] += m[j] * fz
                    ax[j] -= mi   * fx; ay[j] -= mi   * fy; az[j] -= mi   * fz


@nj
def step(x, y, z, u, v, w, m, ax, ay, az, dt, G, eps2, use_symmetry=True, use_blocked=False, block_size=128):
    """
    Fused leapfrog integration step to eliminate Python ⇄ NumPy overhead.
    
    Implements the complete leapfrog scheme in a single JIT-compiled function:
    1. Half-kick: update velocities by half a time step
    2. Drift: update positions by full time step
    3. Update accelerations (forces)
    4. Complete the kick: update velocities by remaining half time step
    
    Parameters:
    -----------
    x, y, z, u, v, w, m : np.ndarray[float32]
        Particle positions, velocities, and masses
    ax, ay, az : np.ndarray[float32]
        Pre-allocated acceleration arrays (modified in-place)
    dt : float32
        Time step
    G : float32
        Gravitational constant
    eps2 : float32
        Softening parameter squared
    use_symmetry : bool
        Whether to use symmetric force computation
    use_blocked : bool
        Whether to use blocked force computation for better cache utilization
    block_size : int
        Block size for cache-friendly computation (64-256 typically optimal)
    """
    n = x.shape[0]
    
    # Step 1: Half-kick (update velocities by half a time step)
    for i in range(n):
        u[i] += 0.5 * dt * ax[i]
        v[i] += 0.5 * dt * ay[i]
        w[i] += 0.5 * dt * az[i]
    
    # Step 2: Drift (update positions by full time step)
    for i in range(n):
        x[i] += dt * u[i]
        y[i] += dt * v[i]
        z[i] += dt * w[i]
    
    # Step 3: Update accelerations (forces)
    if use_symmetry:
        if use_blocked:
            compute_acc_sym_blocked(ax, ay, az, x, y, z, m, G, eps2, block_size)
        else:
            compute_acc_sym_inplace(ax, ay, az, x, y, z, m, G, eps2)
    else:
        compute_acc_full_inplace(ax, ay, az, x, y, z, m, G, eps2)
    
    # Step 4: Complete the kick (update velocities by remaining half time step)
    for i in range(n):
        u[i] += 0.5 * dt * ax[i]
        v[i] += 0.5 * dt * ay[i]
        w[i] += 0.5 * dt * az[i]


@nj
def kinetic_energy(m, u, v, w):
    """
    Compute total kinetic energy of the system.
    
    KE = Σ(½ × m × v²) for all particles
    
    Parameters:
    -----------
    m, u, v, w : np.ndarray[float32]
        Particle masses and velocity components
    
    Returns:
    --------
    float : Total kinetic energy
    """
    ke = 0.0
    for i in range(m.shape[0]):
        # Velocity squared for particle i
        s = float(u[i])*float(u[i]) + float(v[i])*float(v[i]) + float(w[i])*float(w[i])
        ke += 0.5 * float(m[i]) * s
    return ke


@nj
def potential_energy(x, y, z, m, G, eps):
    """
    Compute total gravitational potential energy of the system.
    
    PE = -G × Σ(mᵢ × mⱼ / rᵢⱼ) for all particle pairs
    
    Parameters:
    -----------
    x, y, z, m : np.ndarray[float32]
        Particle positions and masses
    G : float
        Gravitational constant
    eps : float
        Softening parameter
    
    Returns:
    --------
    float : Total potential energy
    """
    N = x.shape[0]
    pe = 0.0
    eps2 = float(eps * eps)
    
    # Sum over all particle pairs (i < j to avoid double counting)
    for i in range(N - 1):
        xi, yi, zi = float(x[i]), float(y[i]), float(z[i])
        mi = float(m[i])
        
        for j in range(i + 1, N):
            # Distance between particles i and j
            dx = float(x[j]) - xi
            dy = float(y[j]) - yi
            dz = float(z[j]) - zi
            r = np.sqrt(dx*dx + dy*dy + dz*dz + eps2)
            
            # Gravitational potential energy between this pair
            pe += -float(G) * mi * float(m[j]) / r
            
    return pe

# =============================================================================
# INITIAL CONDITION GENERATORS
# =============================================================================

def _disk(N, mass_total, Rmax=1.2, z_thick=0.1, v_rot=0.9, jitter=0.05, rng=None):
    """
    Generate initial conditions for a rotating stellar disk.
    
    Creates a 2D disk with small thickness in the z-direction.
    Particles are distributed with circular velocities for orbital stability.
    
    Parameters:
    -----------
    N : int
        Number of particles
    mass_total : float
        Total mass of the disk
    Rmax : float
        Maximum radius of the disk
    z_thick : float
        Thickness of the disk in z-direction
    v_rot : float
        Rotation velocity scaling factor
    jitter : float
        Random velocity perturbation magnitude
    rng : np.random.Generator
        Random number generator
    
    Returns:
    --------
    x, y, z, u, v, w, m : np.ndarray[float32]
        Particle positions, velocities, and masses
    """
    if rng is None:
        # Use the global seeded RNG for consistency
        rng = np.random.default_rng(SEED)
    
    # Generate radial positions (more particles near center)
    R = Rmax * np.sqrt(rng.random(N, dtype=np.float32))
    
    # Generate random azimuthal angles
    theta = 2*np.pi * rng.random(N, dtype=np.float32)
    
    # Convert to Cartesian coordinates
    x = R * np.cos(theta)
    y = R * np.sin(theta)
    z = z_thick * 0.5 * rng.standard_normal(N, dtype=np.float32)

    # Circular velocity for orbital stability
    # v = v_rot × R / (0.3 + R) gives a realistic rotation curve
    vtan = v_rot * R / (0.3 + R)
    u = -vtan * np.sin(theta)  # x-velocity component
    v =  vtan * np.cos(theta)  # y-velocity component
    w = np.zeros_like(u)       # z-velocity component

    # Add random velocity perturbations for realistic dynamics
    u += jitter * rng.standard_normal(N, dtype=np.float32)
    v += jitter * rng.standard_normal(N, dtype=np.float32)
    w += 0.5*jitter * rng.standard_normal(N, dtype=np.float32)

    # Equal mass particles
    m = (mass_total / N) * np.ones(N, dtype=np.float32)
    return x, y, z, u, v, w, m


def _spiral_disk(
    N, mass_total,
    *, Rd=0.6, Rmax=1.8,
    m=2, pitch_deg=18.0, arm_amp=0.65,
    z_thick=0.08,
    v0=1.0, v_rise=0.35,
    nudge_r=0.05, nudge_t=0.02,
    jitter=0.03,
    rng=None, phi0=None
):
    """
    Generate initial conditions for a spiral galaxy disk.
    
    Creates an exponential disk with logarithmic spiral arm overdensities.
    This produces more realistic galaxy morphologies than simple disks.
    
    Parameters:
    -----------
    N : int
        Number of particles
    mass_total : float
        Total mass of the disk
    Rd : float
        Disk scale length (exponential falloff)
    Rmax : float
        Maximum disk radius
    m : int
        Number of spiral arms
    pitch_deg : float
        Pitch angle of spiral arms in degrees
    arm_amp : float
        Amplitude of spiral arm overdensity
    z_thick : float
        Disk thickness
    v0 : float
        Circular velocity at large radius
    v_rise : float
        Radius where velocity reaches v0
    nudge_r, nudge_t : float
        Radial and tangential velocity perturbations for spiral structure
    jitter : float
        Random velocity perturbation
    rng : np.random.Generator
        Random number generator
    phi0 : float
        Initial phase angle for spiral arms
    
    Returns:
    --------
    x, y, z, u, v, w, m : np.ndarray[float32]
        Particle positions, velocities, and masses
    """
    if rng is None:
        # Use the global seeded RNG for consistency
        rng = np.random.default_rng(SEED)
    if phi0 is None:
        phi0 = rng.uniform(0, 2*np.pi)

    # Generate radial positions using gamma distribution (more realistic than uniform)
    R = rng.gamma(shape=2.0, scale=Rd, size=N).astype(np.float32)
    
    # Ensure all particles are within Rmax
    while True:
        mask = R > Rmax
        if not np.any(mask):
            break
        R[mask] = rng.gamma(shape=2.0, scale=Rd, size=np.count_nonzero(mask)).astype(np.float32)

    # Spiral arm parameters
    k = 1.0 / np.tan(np.deg2rad(pitch_deg))  # Spiral pitch parameter
    
    # Generate azimuthal angles with spiral arm overdensity
    theta = np.empty(N, dtype=np.float32)
    filled = 0
    
    # Use rejection sampling to create spiral arm structure
    while filled < N:
        need = N - filled
        th_try = rng.uniform(0, 2*np.pi, size=need*2).astype(np.float32)
        R_rep  = np.repeat(R[filled:filled+need], 2)
        
        # Probability density for spiral arms
        p = 1.0 + arm_amp * np.cos(m * (th_try - k * np.log(R_rep + 1e-6) - phi0))
        uacc = rng.uniform(0, 1.0 + arm_amp, size=th_try.size).astype(np.float32)
        
        # Accept particles based on spiral arm probability
        keep = uacc < p
        n_keep = min(need, int(np.count_nonzero(keep)))
        theta[filled:filled+n_keep] = th_try[keep][:n_keep]
        filled += n_keep

    # Convert to Cartesian coordinates
    x = R * np.cos(theta)
    y = R * np.sin(theta)
    z = z_thick * 0.5 * rng.standard_normal(N, dtype=np.float32)

    # Velocity field with spiral structure
    v_circ = v0 * np.tanh(R / v_rise)  # Circular velocity
    phase = m * (theta - k * np.log(R + 1e-6) - phi0)  # Spiral phase
    
    # Velocity perturbations aligned with spiral arms
    v_r = nudge_r * v_circ * np.cos(phase)  # Radial velocity
    v_t = v_circ * (1.0 + nudge_t * np.sin(phase))  # Tangential velocity

    # Convert to Cartesian velocity components
    u = -v_t * np.sin(theta) + v_r * np.cos(theta)
    v =  v_t * np.cos(theta) + v_r * np.sin(theta)
    w =  0.5 * jitter * rng.standard_normal(N, dtype=np.float32)

    # Add random perturbations
    u += jitter * rng.standard_normal(N, dtype=np.float32)
    v += jitter * rng.standard_normal(N, dtype=np.float32)

    # Equal mass particles
    m = (mass_total / N) * np.ones(N, dtype=np.float32)
    return x, y, z, u, v, w, m


def init_ic(N, seed=17, scenario="galaxy"):
    """
    Generate initial conditions for the N-body simulation.
    
    Creates different particle distributions based on the selected scenario.
    All scenarios are set up in the center-of-mass frame for numerical stability.
    
    Parameters:
    -----------
    N : int
        Number of particles
    seed : int
        Random seed for reproducible results
    scenario : str
        Initial condition type: "galaxy_spiral", "galaxy", "plummer", or "random"
    
    Returns:
    --------
    x, y, z, u, v, w, m : np.ndarray[float32]
        Initial particle positions, velocities, and masses
    """
    rng = np.random.default_rng(seed)

    if scenario == "galaxy_spiral":
        # Two spiral galaxies on collision course
        N1 = N // 2
        N2 = N - N1
        
        # Different initial phases for the two galaxies
        phi1 = rng.uniform(0, 2*np.pi)
        phi2 = phi1 + np.pi / 3.0

        # Generate first spiral galaxy
        x1,y1,z1,u1,v1,w1,m1 = _spiral_disk(
            N1, mass_total=10.0, Rd=0.55, Rmax=1.7,
            m=2, pitch_deg=18.0, arm_amp=0.70, z_thick=0.07,
            v0=1.05, v_rise=0.32, nudge_r=0.06, nudge_t=0.03,
            jitter=0.025, rng=rng, phi0=phi1
        )
        
        # Generate second spiral galaxy
        x2,y2,z2,u2,v2,w2,m2 = _spiral_disk(
            N2, mass_total=10.0, Rd=0.55, Rmax=1.7,
            m=2, pitch_deg=18.0, arm_amp=0.70, z_thick=0.07,
            v0=1.05, v_rise=0.32, nudge_r=0.06, nudge_t=0.03,
            jitter=0.025, rng=rng, phi0=phi2
        )

        # Reverse velocity of second galaxy and offset positions
        u2, v2 = -u2, -v2  # Counter-rotating
        d   = 2.1           # Initial separation
        vcm = 0.45          # Center-of-mass velocity
        
        # Position and velocity offsets for collision
        x1 += -d; v1 += +vcm
        x2 += +d; v2 += -vcm

        # Combine the two galaxies
        x = np.concatenate([x1, x2]).astype(np.float32)
        y = np.concatenate([y1, y2]).astype(np.float32)
        z = np.concatenate([z1, z2]).astype(np.float32)
        u = np.concatenate([u1, u2]).astype(np.float32)
        v = np.concatenate([v1, v2]).astype(np.float32)
        w = np.concatenate([w1, w2]).astype(np.float32)
        m = np.concatenate([m1, m2]).astype(np.float32)

    elif scenario == "galaxy":
        # Two simple disk galaxies on collision course
        N1 = N // 2
        N2 = N - N1
        
        # Generate two identical disk galaxies
        x1,y1,z1,u1,v1,w1,m1 = _disk(N1, 10.0, Rmax=1.1, z_thick=0.08, v_rot=1.0, jitter=0.05, rng=rng)
        x2,y2,z2,u2,v2,w2,m2 = _disk(N2, 10.0, Rmax=1.1, z_thick=0.08, v_rot=1.0, jitter=0.05, rng=rng)
        
        # Counter-rotating galaxies
        u2, v2 = -u2, -v2
        d   = 2.0           # Initial separation
        vcm = 0.5           # Center-of-mass velocity
        
        # Position and velocity offsets
        x1 += -d; v1 += +vcm
        x2 += +d; v2 += -vcm

        # Combine the galaxies
        x = np.concatenate([x1,x2]).astype(np.float32)
        y = np.concatenate([y1,y2]).astype(np.float32)
        z = np.concatenate([z1,z2]).astype(np.float32)
        u = np.concatenate([u1,u2]).astype(np.float32)
        v = np.concatenate([v1,v2]).astype(np.float32)
        w = np.concatenate([w1,w2]).astype(np.float32)
        m = np.concatenate([m1,m2]).astype(np.float32)

    elif scenario == "plummer":
        # Plummer sphere: a realistic model for globular clusters
        a = 0.5  # Scale radius
        
        # Generate positions using Plummer distribution
        u = rng.random(N, dtype=np.float32)
        r = a / np.sqrt(u**(-2/3) - 1.0 + 1e-6)  # Radial distribution
        
        # Random spherical angles
        phi = 2*np.pi * rng.random(N, dtype=np.float32)      # Azimuthal
        cos_t = 2*rng.random(N, dtype=np.float32)-1          # Cosine of polar
        sin_t = np.sqrt(1 - cos_t**2)                        # Sine of polar
        
        # Convert to Cartesian coordinates
        x = r * sin_t * np.cos(phi)
        y = r * sin_t * np.sin(phi)
        z = r * cos_t
        
        # Small random velocities
        u = 0.02 * rng.standard_normal(N, dtype=np.float32)
        v = 0.02 * rng.standard_normal(N, dtype=np.float32)
        w = 0.02 * rng.standard_normal(N, dtype=np.float32)
        m = (20.0 / N) * np.ones(N, dtype=np.float32)

    else:  # "random"
        # Random particle distribution (useful for testing)
        x = rng.standard_normal(N, dtype=np.float32)
        y = rng.standard_normal(N, dtype=np.float32)
        z = rng.standard_normal(N, dtype=np.float32)
        u = rng.standard_normal(N, dtype=np.float32)
        v = rng.standard_normal(N, dtype=np.float32)
        w = rng.standard_normal(N, dtype=np.float32)
        m = (20.0 / N) * np.ones(N, dtype=np.float32)

    # Transform to center-of-mass frame for numerical stability
    # This prevents the entire system from drifting
    mu = np.mean(m * u); mv = np.mean(m * v); mw = np.mean(m * w)
    mbar = np.mean(m)
    u -= mu / mbar; v -= mv / mbar; w -= mw / mbar
    
    return x, y, z, u, v, w, m

# =============================================================================
# VISUALIZATION HELPER FUNCTIONS
# =============================================================================

def _style_axes_dark(ax):
    """Apply dark theme styling to a matplotlib axis."""
    ax.set_facecolor("black")
    for spine in ax.spines.values():
        spine.set_color("#888888")
    ax.tick_params(colors="#dddddd")
    ax.xaxis.label.set_color("#ffffff")
    ax.yaxis.label.set_color("#ffffff")
    ax.title.set_color("#ffffff")


def _style_axes_light(ax):
    """Apply light theme styling to a matplotlib axis."""
    ax.set_facecolor("white")
    for spine in ax.spines.values():
        spine.set_color("#333333")
    ax.tick_params(colors="#111111")
    ax.xaxis.label.set_color("#111111")
    ax.yaxis.label.set_color("#111111")
    ax.title.set_color("#111111")


def _setup_figure():
    """
    Create and configure the main visualization figure.
    
    Sets up a 3-panel layout: positions (top 2/3) and energy (bottom 1/3).
    
    Returns:
    --------
    fig : matplotlib.figure.Figure
        The main figure
    ax_pos : matplotlib.axes.Axes
        Axes for particle positions (dark theme)
    ax_eng : matplotlib.axes.Axes
        Axes for energy plots (light theme)
    """
    fig = plt.figure(figsize=(6.5, 7.5), dpi=110)
    grid = plt.GridSpec(3, 1, wspace=0.0, hspace=0.32, height_ratios=[1.0, 1.0, 0.9])
    ax_pos = plt.subplot(grid[0:2, 0])   # Dark theme for positions
    ax_eng = plt.subplot(grid[2, 0])     # Light theme for energy
    _style_axes_dark(ax_pos)
    _style_axes_light(ax_eng)
    return fig, ax_pos, ax_eng


def _render_snapshot(path, x, y, z, u, v, w, title_str, times=None, KE_save=None, PE_save=None):
    """
    Save a two-panel snapshot matching the live visualization.
    
    Creates a standalone figure with the same layout as the live visualization:
    - Top panel: Particle positions with dark theme
    - Bottom panel: Energy evolution with light theme
    
    Parameters:
    -----------
    path : str
        File path for saving the image
    x, y, z, u, v, w : np.ndarray
        Particle positions and velocities
    title_str : str
        Title for the plot
    times : np.ndarray, optional
        Time points for energy history
    KE_save : np.ndarray, optional
        Kinetic energy history
    PE_save : np.ndarray, optional
        Potential energy history
    """
    if times is not None and KE_save is not None and PE_save is not None:
        # Two-panel layout matching live visualization
        fig = plt.figure(figsize=(6.8, 8.2), dpi=120)
        gs = fig.add_gridspec(3, 1, hspace=0.3)
        
        # Upper 2 panels merged for positions (dark theme)
        ax_pos = fig.add_subplot(gs[:2, 0])
        _style_axes_dark(ax_pos)
        
        # Color particles by speed
        speed = np.sqrt(u*u + v*v + w*w)
        smin, smax = np.percentile(speed, [5, 95])
        smax = max(smax, smin + 1e-6)
        cmap = plt.get_cmap(CMAP)
        color = cmap(np.clip((speed - smin) / (smax - smin), 0, 1))

        # Apply depth cueing if enabled
        if DEPTH_CUE:
            zmin, zmax = np.percentile(z, [5, 95])
            zrange = max(zmax - zmin, 1e-3)
            depth = np.clip((z - zmin) / zrange, 0, 1)
            sizes = POINT_SIZE * (0.6 + 0.8*(1.0 - depth))  # Nearer = bigger
            color[:, 3] = 0.6 + 0.4*(1.0 - depth)           # Nearer = more opaque
        else:
            sizes = POINT_SIZE * np.ones_like(x)

        # Plot particles
        ax_pos.scatter(x, y, s=sizes, c=color, linewidths=0)
        ax_pos.set_aspect("equal", "box")
        ax_pos.set_xlim(-BOUNDS, BOUNDS)
        ax_pos.set_ylim(-BOUNDS, BOUNDS)
        ax_pos.set_title(title_str)
        
        # Bottom panel for energies (light theme)
        ax_eng = fig.add_subplot(gs[2, 0])
        _style_axes_light(ax_eng)
        
        # Plot energy evolution
        ax_eng.plot(times, KE_save, color="#cc3333", lw=1.1, label='KE')
        ax_eng.plot(times, PE_save, color="#3366cc", lw=1.1, label='PE')
        ax_eng.plot(times, (KE_save + PE_save), color="#222222", lw=1.2, label='Etot')
        ax_eng.set_xlim(0, max(times))
        ax_eng.set_xlabel("Time [-]")
        ax_eng.set_ylabel("Energy [-]")
        
        # Add legend
        leg = ax_eng.legend(loc="upper right", fontsize=8,
                            facecolor="#f6f6f6", edgecolor="#999999")
        for txt in leg.get_texts():
            txt.set_color("#111111")
    else:
        # Single panel for initial snapshot (no energy data yet)
        fig, ax = plt.subplots(figsize=(7, 7), dpi=120)
        _style_axes_dark(ax)

        # Color particles by speed
        speed = np.sqrt(u*u + v*v + w*w)
        smin, smax = np.percentile(speed, [5, 95])
        smax = max(smax, smin + 1e-6)
        cmap = plt.get_cmap(CMAP)
        color = cmap(np.clip((speed - smin) / (smax - smin), 0, 1))

        # Apply depth cueing if enabled
        if DEPTH_CUE:
            zmin, zmax = np.percentile(z, [5, 95])
            zrange = max(zmax - zmin, 1e-3)
            depth = np.clip((z - zmin) / zrange, 0, 1)
            sizes = POINT_SIZE * (0.6 + 0.8*(1.0 - depth))  # Nearer = bigger
            color[:, 3] = 0.6 + 0.4*(1.0 - depth)           # Nearer = more opaque
        else:
            sizes = POINT_SIZE * np.ones_like(x)

        # Plot particles
        ax.scatter(x, y, s=sizes, c=color, linewidths=0)
        ax.set_aspect("equal", "box")
        ax.set_xlim(-BOUNDS, BOUNDS)
        ax.set_ylim(-BOUNDS, BOUNDS)
        ax.set_title(title_str)
        ax.set_xlabel("x"); ax.set_ylabel("y")
    
    # Save and close
    plt.savefig(path, dpi=220)
    plt.close(fig)

# =============================================================================
# MAIN SIMULATION FUNCTION
# =============================================================================

def main():
    """
    Main simulation function (optimized version).
    
    Implements the leapfrog integration scheme using optimized kernels:
    1. Preallocates acceleration arrays to avoid per-step allocations
    2. Uses fused step function to eliminate Python ⇄ NumPy overhead
    3. Includes kernel warm-up to exclude compilation time from timing
    4. Maintains fair comparison with other language implementations
    
    This scheme conserves energy better than simple Euler integration.
    """
    # Initialize particle system
    if IMPORT_IC is not None:
        # Import initial conditions from file
        print(f"Importing initial conditions from: {IMPORT_IC}")
        try:
            x, y, z, u, v, w, m, file_G, file_softening = import_initial_conditions(IMPORT_IC)
            
            # Use parameters from the imported file
            G_actual = file_G
            softening_actual = file_softening
            N_actual = len(x)
            
            print(f"Using imported parameters: G={G_actual}, softening={softening_actual}, N={N_actual}")
            
            # Use imported N for the simulation
            if N_actual != N:
                print(f"Warning: Imported N={N_actual} differs from configured N={N}")
                print(f"Using imported value: N={N_actual}")
            
        except Exception as e:
            print(f"Error importing initial conditions: {e}")
            print("Falling back to generated initial conditions...")
            x, y, z, u, v, w, m = init_ic(N, SEED, SCENARIO)
            G_actual = G
            softening_actual = softening
            N_actual = N
    else:
        # Generate initial conditions using current method
        print(f"Initializing {SCENARIO} scenario with {N} particles...")
        x, y, z, u, v, w, m = init_ic(N, SEED, SCENARIO)
        G_actual = G
        softening_actual = softening
        N_actual = N
    
    # Ensure all arrays are contiguous float32 for optimal performance
    x = np.ascontiguousarray(x, dtype=np.float32)
    y = np.ascontiguousarray(y, dtype=np.float32)
    z = np.ascontiguousarray(z, dtype=np.float32)
    u = np.ascontiguousarray(u, dtype=np.float32)
    v = np.ascontiguousarray(v, dtype=np.float32)
    w = np.ascontiguousarray(w, dtype=np.float32)
    m = np.ascontiguousarray(m, dtype=np.float32)
    
    # Preallocate acceleration arrays (no per-step allocations)
    ax = np.zeros(N_actual, dtype=np.float32)
    ay = np.zeros(N_actual, dtype=np.float32)
    az = np.zeros(N_actual, dtype=np.float32)
    
    # Precompute constants as float32
    dt_f32 = np.float32(dt)
    G_f32 = np.float32(G_actual)
    eps2 = np.float32(softening_actual * softening_actual)
    
    # KERNEL WARM-UP: Run one step with FULL-SIZE arrays to compile kernels
    # This ensures compilation time is not included in performance measurements
    # CRITICAL: Must use same array sizes as main computation to avoid recompilation!
    print("Warming up JIT kernels...")
    print(f"Using full array size N={N_actual} for proper JIT compilation...")
    x_warm = x.copy()
    y_warm = y.copy()
    z_warm = z.copy()
    u_warm = u.copy()
    v_warm = v.copy()
    w_warm = w.copy()
    m_warm = m.copy()
    ax_warm = np.zeros(N_actual, dtype=np.float32)
    ay_warm = np.zeros(N_actual, dtype=np.float32)
    az_warm = np.zeros(N_actual, dtype=np.float32)
    
    # Warm up the force computation kernels with identical function signatures
    if USE_SYM:
        if USE_BLOCKED:
            compute_acc_sym_blocked(ax_warm, ay_warm, az_warm, x_warm, y_warm, z_warm, m_warm, G_f32, eps2, BLOCK_SIZE)
        else:
            ax_warm, ay_warm, az_warm = compute_acc_sym_inplace(ax_warm, ay_warm, az_warm, x_warm, y_warm, z_warm, m_warm, G_f32, eps2)
    else:
        compute_acc_full_inplace(ax_warm, ay_warm, az_warm, x_warm, y_warm, z_warm, m_warm, G_f32, eps2)
    
    # Also warm up the energy computation functions if they exist
    try:
        _ = kinetic_energy(m_warm, u_warm, v_warm, w_warm)
        _ = potential_energy(x_warm, y_warm, z_warm, m_warm, G_actual, softening_actual)
    except:
        pass  # Energy functions might not be JIT compiled
    
    print("Kernel warm-up complete! All functions compiled with correct signatures.")
    
    # Compute initial accelerations using optimized kernels
    print("Computing initial forces...")
    if USE_SYM:
        if USE_BLOCKED:
            compute_acc_sym_blocked(ax, ay, az, x, y, z, m, G_f32, eps2, BLOCK_SIZE)
        else:
            ax, ay, az = compute_acc_sym_inplace(ax, ay, az, x, y, z, m, G_f32, eps2)
    else:
        compute_acc_full_inplace(ax, ay, az, x, y, z, m, G_f32, eps2)

    # Save initial snapshot if requested
    if STOREFINAL:
        print("Saving initial snapshot...")
        _render_snapshot(
            os.path.join(OUT_DIR, f"nbody_{SCENARIO}_initial_python.png"),
            x, y, z, u, v, w,
            f"{SCENARIO.capitalize()} – initial"
        )

    # Time integration setup
    Nt = int(np.ceil(tEnd / dt))
    print(f"Running simulation for {Nt} time steps (dt={dt}, tEnd={tEnd})...")

    if VISUALIZE:
        # Setup real-time visualization
        print("Setting up visualization...")
        fig, ax_pos, ax_eng = _setup_figure()
        
        # Trail buffers for particle history
        trail_x = np.zeros((TRAIL, N), dtype=np.float32)
        trail_y = np.zeros((TRAIL, N), dtype=np.float32)
        trail_len = 0
        trail_idx = 0

        # Energy tracking arrays
        times = np.empty(Nt + 1, dtype=np.float64)
        KE_save = np.empty(Nt + 1, dtype=np.float64)
        PE_save = np.empty(Nt + 1, dtype=np.float64)

        # Initial energy values
        KE_save[0] = kinetic_energy(m, u, v, w)
        PE_save[0] = potential_energy(x, y, z, m, G, softening)
        times[0]   = 0.0

        cmap = plt.get_cmap(CMAP)

    # Main time integration loop using truly optimized approach
    t = 0.0
    for it in range(1, Nt + 1):
        # LEAPFROG INTEGRATION SCHEME (NumPy vectorized O(N) + Numba JIT O(N²))
        
        # Step 1: Half-kick (update velocities by half a time step)
        u += 0.5 * dt_f32 * ax
        v += 0.5 * dt_f32 * ay
        w += 0.5 * dt_f32 * az

        # Step 2: Drift (update positions by full time step)
        x += dt_f32 * u
        y += dt_f32 * v
        z += dt_f32 * w

        # Step 3: Update accelerations (forces) using optimized in-place computation
        if USE_SYM:
            if USE_BLOCKED:
                compute_acc_sym_blocked(ax, ay, az, x, y, z, m, G_f32, eps2, BLOCK_SIZE)
            else:
                ax, ay, az = compute_acc_sym_inplace(ax, ay, az, x, y, z, m, G_f32, eps2)
        else:
            compute_acc_full_inplace(ax, ay, az, x, y, z, m, G_f32, eps2)

        # Step 4: Complete the kick (update velocities by remaining half time step)
        u += 0.5 * dt_f32 * ax
        v += 0.5 * dt_f32 * ay
        w += 0.5 * dt_f32 * az
        t += dt

        # Real-time visualization updates
        if VISUALIZE:
            # Track energy conservation
            KE_save[it] = kinetic_energy(m, u, v, w)
            PE_save[it] = potential_energy(x, y, z, m, G, softening)
            times[it]   = t

            # Update particle trails
            trail_x[trail_idx, :] = x
            trail_y[trail_idx, :] = y
            trail_idx = (trail_idx + 1) % TRAIL
            trail_len = min(trail_len + 1, TRAIL)
            idxs = (np.arange(trail_len) + (trail_idx - trail_len)) % TRAIL
            xx = trail_x[idxs, :]
            yy = trail_y[idxs, :]

            # Color particles by speed
            speed = np.sqrt(u*u + v*v + w*w)
            smin, smax = np.percentile(speed, [5, 95])
            smax = max(smax, smin + 1e-6)
            color = cmap(np.clip((speed - smin) / (smax - smin), 0, 1))

            # Apply depth cueing
            if DEPTH_CUE:
                zmin, zmax = np.percentile(z, [5, 95])
                zrange = max(zmax - zmin, 1e-3)
                depth = np.clip((z - zmin) / zrange, 0, 1)
                sizes = POINT_SIZE * (0.6 + 0.8*(1.0 - depth))   # Nearer = bigger
                color[:, 3] = 0.6 + 0.4*(1.0 - depth)            # Nearer = more opaque
            else:
                sizes = POINT_SIZE * np.ones_like(x)

            # Update positions panel (dark theme)
            ax_pos.cla()
            
            # Draw particle trails
            if trail_len > 1:
                alphas = np.linspace(0.08, 0.35, trail_len)
                sizes_trail = np.linspace(0.5*POINT_SIZE, 0.9*POINT_SIZE, trail_len)
                for xxk, yyk, ak, sk in zip(xx, yy, alphas, sizes_trail):
                    ax_pos.scatter(xxk, yyk, s=sk, color=(0.7, 0.7, 1.0, ak), linewidths=0)

            # Draw current particle positions
            ax_pos.scatter(x, y, s=sizes, c=color, linewidths=0)
            ax_pos.set_aspect("equal", "box")
            ax_pos.set_xlim(-BOUNDS, BOUNDS)
            ax_pos.set_ylim(-BOUNDS, BOUNDS)
            ax_pos.set_title(f"{SCENARIO.capitalize()}  (N={N})   t = {t:.2f}")
            _style_axes_dark(ax_pos)  # Re-apply styling after clearing

            # Update energy panel (light theme)
            ax_eng.cla()
            ax_eng.plot(times[:it+1], KE_save[:it+1], color="#cc3333", lw=1.1, label='KE')
            ax_eng.plot(times[:it+1], PE_save[:it+1], color="#3366cc", lw=1.1, label='PE')
            ax_eng.plot(times[:it+1], (KE_save[:it+1] + PE_save[:it+1]),
                        color="#222222", lw=1.2, label='Etot')
            ax_eng.set_xlim(0, tEnd)
            ax_eng.set_xlabel("time")
            ax_eng.set_ylabel("energy")
            _style_axes_light(ax_eng)  # Keep energy panel readable
            
            # Add legend
            leg = ax_eng.legend(loc="upper right", fontsize=8,
                                facecolor="#f6f6f6", edgecolor="#999999")
            for txt in leg.get_texts():
                txt.set_color("#111111")

            # Update display
            plt.pause(0.001)

    # Save final snapshot if requested
    if STOREFINAL:
        print("Saving final snapshot...")
        if VISUALIZE:
            # Save the existing live visualization figure (which already has correct styling)
            # This preserves the black background for galaxies panel and white background for energy panel
            plt.savefig(os.path.join(OUT_DIR, f"nbody_{SCENARIO}_final_python.png"), dpi=220)
        else:
            # No energy data available when VISUALIZE=false
            # Create a simple snapshot with just particle positions
            _render_snapshot(
                os.path.join(OUT_DIR, f"nbody_{SCENARIO}_final_python.png"),
                x, y, z, u, v, w,
                f"{SCENARIO.capitalize()} – final  (t = {t:.2f})"
            )

    # Note: Final visualization is already saved above when VISUALIZE=true
    # No need to save the live visualization figure separately
    
    print("Simulation complete!")

# =============================================================================
# SCRIPT ENTRY POINT
# =============================================================================

if __name__ == "__main__":
    main()
