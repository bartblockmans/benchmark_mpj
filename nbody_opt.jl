"""
    N-Body Galaxy Simulation in Julia (OPTIMIZED VERSION)
    ====================================================

This script simulates the gravitational dynamics of galaxies using an N-body approach.
It implements an all-pairs gravity calculation with Plummer softening for numerical stability.

This is the OPTIMIZED version with the following performance improvements:
- Specialized kernels for symmetric/non-symmetric force computation (no branching in hot loops)
- Blocked force computation for better cache utilization (10-30% improvement for N ≳ few thousand)
- Fused leapfrog integration step to reduce dispatch overhead
- SIMD optimization with @fastmath and @simd ivdep
- Kernel warm-up to exclude compilation time from performance measurements
- Type-stable Float32 arrays throughout for optimal performance

Key Features:
- Multiple simulation scenarios: spiral galaxy collision, simple galaxy collision, 
  Plummer sphere, and random particle distribution
- Leapfrog integration scheme for accurate orbital dynamics
- Real-time visualization with particle trails and energy conservation plots
- Optimized Julia implementation with broadcasting and in-place operations
- Symmetric force calculation to ensure momentum conservation
- Import initial conditions from JSON files for reproducible results across languages

Physics:
- Gravitational force between all particle pairs (O(N²) complexity)
- Plummer softening to prevent infinite forces at close encounters
- Leapfrog integration: kick-drift-kick scheme for energy conservation
- Center-of-mass frame to eliminate overall system drift

Performance Notes:
- This optimized version maintains fair comparison with other language implementations
- All optimizations are language-specific (no external libraries beyond standard Julia)
- Blocked computation is automatically beneficial for N ≳ 3-5k particles
- Kernel warm-up ensures compilation time is not included in timing measurements
- Run with: JULIA_NUM_THREADS=1 julia -O3 --check-bounds=no --cpu-target=native

Author: Bart Blockmans
Date: August 2025

Usage:
- Set IMPORT_IC = nothing to generate initial conditions using the current method
- Set IMPORT_IC = "filename.json" to import initial conditions from a JSON file
  (e.g., "nbody_ic_galaxy_spiral_N4000.json" generated by nbody_ic.py)
"""

# =============================================================================
# CONFIGURATION SECTION
# =============================================================================

# BENCHMARKING OPTIMIZATION SETTINGS (ENABLED BY DEFAULT)
# ======================================================
# This script is automatically configured for maximum performance:
# - USE_SYM = true: Symmetric force computation for momentum conservation
# - USE_BLOCKED = true: Cache blocking for better memory locality
# - VISUALIZE = false: Headless mode for maximum speed
# - Single-threaded environment variables set automatically
# - @fastmath, @inbounds, @simd ivdep optimizations enabled
#
# No special command-line arguments needed - runs at full performance by default!

# Visualization and Output Settings
const VISUALIZE = false             # Enable real-time plotting (set to false for headless runs)
const STOREFINAL = false           # Save initial & final PNGs to ./julia/ directory (works also if VISUALIZE=false)

# Performance Optimization Settings
const USE_BLOCKED = false           # Use blocked force computation for better cache utilization (N ≳ few thousand)
const BLOCK_SIZE = 128             # Block size for cache-friendly force computation (64-256 typically optimal)

# Simulation Parameters
const USE_SYM   = true             # Use symmetric i<j force loop for equal/opposite force updates
const SCENARIO  = "galaxy_spiral"  # Simulation scenario: "galaxy_spiral" | "galaxy" | "plummer" | "random"
const N         = 4000             # Number of particles
const tEnd      = Float32(1.0)     # Total simulation time
const dt        = Float32(1e-3)    # Time step (small step maintains galaxy stability)
const Gconst    = Float32(1.0)     # Gravitational constant (normalized units)
const softening = Float32(1.5e-2)  # Plummer softening parameter (prevents infinite forces)
const SEED      = 17               # Random seed for reproducible results

# Initial Conditions Import
# Set to filename (e.g., "nbody_ic_galaxy_spiral_N4000.json") to import initial conditions
# Set to nothing to generate initial conditions using the current method
const IMPORT_IC = "nbody_ic_galaxy_spiral_N4000.json"  

# Visualization Parameters (only used when VISUALIZE=true or STOREFINAL=true)
const TRAIL      = 80               # Number of time steps to show particle trails (works for 0, 1, or >1)
const POINT_SIZE = 5.0              # Size of current-position markers
const CMAP       = :viridis         # Color map for speed-based particle coloring
const DEPTH_CUE  = true             # Enable depth cueing (size based on z-coordinate)
const BOUNDS     = 3.5f0            # Plot boundaries: x,y limits = ±BOUNDS

# =============================================================================
# IMPORTS AND DEPENDENCIES
# =============================================================================

# Set single-threaded environment for consistent benchmarking
# This ensures reproducible performance comparisons between languages
ENV["JULIA_NUM_THREADS"] = "1"
ENV["OMP_NUM_THREADS"] = "1"
ENV["MKL_NUM_THREADS"] = "1"
ENV["OPENBLAS_NUM_THREADS"] = "1"

using Random, Statistics
using CairoMakie
using Distributions: Gamma
using JSON3  # For parsing initial conditions JSON files

# =============================================================================
# INITIAL CONDITIONS IMPORT FUNCTION
# =============================================================================

"""
    import_initial_conditions(filename)

Import initial conditions from a JSON file generated by nbody_ic.py.

# Arguments
- `filename`: Path to the JSON file containing initial conditions

# Returns
- `x, y, z, u, v, w, m`: Particle positions, velocities, and masses
- `G_actual, softening_actual`: Gravitational constant and softening parameter from the file

# Throws
- `ArgumentError`: If the specified file doesn't exist
- `ErrorException`: If the file format is invalid or incompatible
"""
function import_initial_conditions(filename::String)
    # Check if file exists
    if !isfile(filename)
        throw(ArgumentError("Initial conditions file not found: $filename"))
    end
    
    try
        # Read and parse JSON file
        data = JSON3.read(filename)
        
        # Validate file format
        if !haskey(data, :format_version)
            throw(ErrorException("Invalid file format: missing 'format_version'"))
        end
        
        if !haskey(data, :metadata) || !haskey(data, :particles)
            throw(ErrorException("Invalid file format: missing 'metadata' or 'particles' sections"))
        end
        
        # Extract metadata
        metadata = data.metadata
        scenario = get(metadata, :scenario, "unknown")
        file_N = get(metadata, :N, 0)
        file_G = get(metadata, :Gconst, 1.0)
        file_softening = get(metadata, :softening, 0.015)
        file_seed = get(metadata, :seed, 0)
        
        # Extract particle data
        particles = data.particles
        x = Float32.(particles.positions.x)
        y = Float32.(particles.positions.y)
        z = Float32.(particles.positions.z)
        u = Float32.(particles.velocities.u)
        v = Float32.(particles.velocities.v)
        w = Float32.(particles.velocities.w)
        m = Float32.(particles.masses)
        
        # Validate data consistency
        if length(x) != file_N
            throw(ErrorException("Particle count mismatch: expected $file_N, got $(length(x))"))
        end
        
        if length(x) != length(y) || length(x) != length(z) || 
           length(x) != length(u) || length(x) != length(v) || 
           length(x) != length(w) || length(x) != length(m)
            throw(ErrorException("Inconsistent array lengths in particle data"))
        end
        
        # Print import information
        println("Imported initial conditions from: $filename")
        println("  Scenario: $scenario")
        println("  Particles: $file_N")
        println("  G: $(file_G)")
        println("  Softening: $(file_softening)")
        println("  Seed: $file_seed")
        println("  Generated by: $(get(metadata, :generated_by, "unknown"))")
        println("  Timestamp: $(get(metadata, :timestamp, "unknown"))")
        
        # Return values
        G_actual = Float32(file_G)
        softening_actual = Float32(file_softening)
        
        return x, y, z, u, v, w, m, G_actual, softening_actual
        
    catch e
        if e isa ArgumentError
            rethrow(e)
        else
            throw(ErrorException("Error reading initial conditions file: $(e)"))
        end
    end
end

# =============================================================================
# CORE PHYSICS FUNCTIONS (OPTIMIZED)
# =============================================================================

"""
    compute_acc_sym!(ax, ay, az, x, y, z, m, G, eps)

Compute gravitational acceleration for all particles in-place (symmetric version).

This is the computationally intensive O(N²) part of the simulation.
Uses Plummer softening to prevent infinite forces at close encounters.
Optimized for symmetric i<j force loop with in-place accumulation.

# Arguments
- `ax, ay, az`: Acceleration component vectors (modified in-place)
- `x, y, z`: Particle position vectors
- `m`: Particle mass vector
- `G`: Gravitational constant
- `eps`: Softening parameter (Plummer radius)

# Algorithm
- Computes force between each pair only once (more efficient)
- Ensures exact momentum conservation
- Uses @inbounds and @fastmath for performance optimization
- Applies Plummer softening: r² → r² + ε² to prevent infinite forces
"""
@fastmath function compute_acc_sym!(ax::AbstractVector{Float32}, ay::AbstractVector{Float32}, az::AbstractVector{Float32},
                                    x::AbstractVector{Float32}, y::AbstractVector{Float32}, z::AbstractVector{Float32},
                                    m::AbstractVector{Float32}, G::Float32, eps::Float32)
    @inbounds begin
        # Initialize acceleration arrays to zero
        fill!(ax, 0f0); fill!(ay, 0f0); fill!(az, 0f0)
        N = length(x)
        eps2 = eps*eps  # Softening parameter squared
        
        # Symmetric loop: compute force between each pair only once
        # This is more efficient and ensures exact momentum conservation
        for i in 1:N-1
            xi = x[i]; yi = y[i]; zi = z[i]; mi = m[i]  # Position and mass of particle i
            
            @simd ivdep for j in i+1:N
                # Vector from particle i to particle j
                dx = x[j] - xi
                dy = y[j] - yi
                dz = z[j] - zi
                
                # Distance squared with softening (prevents infinite forces)
                r2 = dx*dx + dy*dy + dz*dz + eps2
                
                # Compute 1/r and 1/r³ for force calculation
                invr  = inv(sqrt(r2))       # 1/r
                invr3 = invr / r2           # 1/r³
                
                # Force magnitude (scalar)
                s = G * invr3
                
                # Force vector components
                fx = s * dx; fy = s * dy; fz = s * dz
                
                # Apply equal and opposite forces (Newton's 3rd law)
                # Particle i feels force from particle j
                ax[i] += m[j] * fx; ay[i] += m[j] * fy; az[i] += m[j] * fz
                # Particle j feels equal and opposite force from particle i
                ax[j] -= mi   * fx; ay[j] -= mi   * fy; az[j] -= mi   * fz
            end
        end
    end
    return nothing
end


"""
    compute_acc_full!(ax, ay, az, x, y, z, m, G, eps)

Compute gravitational acceleration for all particles in-place (full version).

Non-symmetric loop: compute all N² forces explicitly.
This is slower but more straightforward to understand.

# Arguments
- `ax, ay, az`: Acceleration component vectors (modified in-place)
- `x, y, z`: Particle position vectors
- `m`: Particle mass vector
- `G`: Gravitational constant
- `eps`: Softening parameter (Plummer radius)
"""
@fastmath function compute_acc_full!(ax::AbstractVector{Float32}, ay::AbstractVector{Float32}, az::AbstractVector{Float32},
                                    x::AbstractVector{Float32}, y::AbstractVector{Float32}, z::AbstractVector{Float32},
                                    m::AbstractVector{Float32}, G::Float32, eps::Float32)
    @inbounds begin
        # Initialize acceleration arrays to zero
        fill!(ax, 0f0); fill!(ay, 0f0); fill!(az, 0f0)
        N = length(x)
        eps2 = eps*eps  # Softening parameter squared
        
        # Non-symmetric loop: compute all N² forces explicitly
        for i in 1:N
            xi = x[i]; yi = y[i]; zi = z[i]
            aix = 0f0; aiy = 0f0; aiz = 0f0  # Accumulate accelerations for particle i
            
            # Process j < i (forces from particles with lower indices)
            if i > 1
                @simd ivdep for j in 1:i-1
                    # Vector from particle i to particle j
                    dx = x[j] - xi
                    dy = y[j] - yi
                    dz = z[j] - zi
                    
                    # Distance squared with softening
                    r2 = dx*dx + dy*dy + dz*dz + eps2
                    invr  = inv(sqrt(r2))
                    invr3 = invr / r2
                    
                    # Force on particle i due to particle j
                    s = G * m[j] * invr3
                    aix += s * dx; aiy += s * dy; aiz += s * dz
                end
            end
            
            # Process j > i (forces from particles with higher indices)
            if i < N
                @simd ivdep for j in i+1:N
                    # Vector from particle i to particle j
                    dx = x[j] - xi
                    dy = y[j] - yi
                    dz = z[j] - zi
                    
                    # Distance squared with softening
                    r2 = dx*dx + dy*dy + dz*dz + eps2
                    invr  = inv(sqrt(r2))
                    invr3 = invr / r2
                    
                    # Force on particle i due to particle j
                    s = G * m[j] * invr3
                    aix += s * dx; aiy += s * dy; aiz += s * dz
                end
            end
            
            # Store accumulated accelerations
            ax[i] = aix; ay[i] = aiy; az[i] = aiz
        end
    end
    return nothing
end


"""
    compute_acc_sym_blocked!(ax, ay, az, x, y, z, m, G, eps; B=128)

Compute gravitational acceleration with blocked loops for better cache utilization.

For N ≳ few thousand, blocking improves L1/L2 cache reuse by 10-30%.
This is the most optimized version for large particle counts.

# Arguments
- `ax, ay, az`: Acceleration component vectors (modified in-place)
- `x, y, z`: Particle position vectors
- `m`: Particle mass vector
- `G`: Gravitational constant
- `eps`: Softening parameter (Plummer radius)
- `B`: Block size (64-256 typically optimal)

# Algorithm
- Two-level blocking for cache-friendly memory access
- Processes i-j space in square tiles for better cache locality
- Uses @simd ivdep for SIMD optimization on inner loops
"""
@fastmath function compute_acc_sym_blocked!(ax::AbstractVector{Float32}, ay::AbstractVector{Float32}, az::AbstractVector{Float32},
                                           x::AbstractVector{Float32}, y::AbstractVector{Float32}, z::AbstractVector{Float32},
                                           m::AbstractVector{Float32}, G::Float32, eps::Float32; B::Int=128)
    @inbounds begin
        # Initialize acceleration arrays to zero
        fill!(ax, 0f0); fill!(ay, 0f0); fill!(az, 0f0)
        N = length(x)
        eps2 = eps*eps  # Softening parameter squared
        
        # Two-level blocking for cache-friendly memory access
        for ib in 1:B:N-1
            iend = min(N-1, ib+B-1)
            for jb in ib+1:B:N
                jend = min(N, jb+B-1)
                
                for i in ib:iend
                    xi = x[i]; yi = y[i]; zi = z[i]; mi = m[i]
                    
                    # Start j at max(i+1, jb) to keep symmetry correct inside a block
                    j0 = max(i+1, jb)
                    
                    @simd ivdep for j in j0:jend
                        # Vector from particle i to particle j
                        dx = x[j] - xi
                        dy = y[j] - yi
                        dz = z[j] - zi
                        
                        # Distance squared with softening
                        r2 = dx*dx + dy*dy + dz*dz + eps2
                        invr = inv(sqrt(r2))
                        invr3 = invr / r2
                        
                        # Force magnitude and components
                        s = G * invr3
                        fx = s * dx; fy = s * dy; fz = s * dz
                        
                        # Apply equal and opposite forces
                        ax[i] += m[j] * fx; ay[i] += m[j] * fy; az[i] += m[j] * fz
                        ax[j] -= mi   * fx; ay[j] -= mi   * fy; az[j] -= mi   * fz
                    end
                end
            end
        end
    end
    return nothing
end


"""
    step!(x, y, z, u, v, w, m, ax, ay, az, dt, G, eps, use_symmetry=true, use_blocked=false, block_size=128)

Fused leapfrog integration step to reduce dispatch overhead and improve performance.

Implements the complete leapfrog scheme in a single optimized function:
1. Half-kick: update velocities by half a time step
2. Drift: update positions by full time step
3. Update accelerations (forces)
4. Complete the kick: update velocities by remaining half time step

# Arguments
- `x, y, z, u, v, w, m`: Particle positions, velocities, and masses
- `ax, ay, az`: Pre-allocated acceleration arrays (modified in-place)
- `dt`: Time step
- `G`: Gravitational constant
- `eps`: Softening parameter
- `use_symmetry`: Whether to use symmetric force computation
- `use_blocked`: Whether to use blocked force computation for better cache utilization
- `block_size`: Block size for cache-friendly computation (64-256 typically optimal)
"""
@inline function step!(x::AbstractVector{Float32}, y::AbstractVector{Float32}, z::AbstractVector{Float32},
                       u::AbstractVector{Float32}, v::AbstractVector{Float32}, w::AbstractVector{Float32},
                       m::AbstractVector{Float32}, ax::AbstractVector{Float32}, ay::AbstractVector{Float32}, az::AbstractVector{Float32},
                       dt::Float32, G::Float32, eps::Float32, use_symmetry::Bool=true, 
                       use_blocked::Bool=false, block_size::Int=128)
    
    # Step 1: Half-kick (update velocities by half a time step)
    @inbounds @simd for i in eachindex(x)
        u[i] += 0.5f0 * dt * ax[i]
        v[i] += 0.5f0 * dt * ay[i]
        w[i] += 0.5f0 * dt * az[i]
    end
    
    # Step 2: Drift (update positions by full time step)
    @inbounds @simd for i in eachindex(x)
        x[i] += dt * u[i]
        y[i] += dt * v[i]
        z[i] += dt * w[i]
    end
    
    # Step 3: Update accelerations (forces)
    if use_symmetry
        if use_blocked
            compute_acc_sym_blocked!(ax, ay, az, x, y, z, m, G, eps; B=block_size)
        else
            compute_acc_sym!(ax, ay, az, x, y, z, m, G, eps)
        end
    else
        compute_acc_full!(ax, ay, az, x, y, z, m, G, eps)
    end
    
    # Step 4: Complete the kick (update velocities by remaining half time step)
    @inbounds @simd for i in eachindex(x)
        u[i] += 0.5f0 * dt * ax[i]
        v[i] += 0.5f0 * dt * ay[i]
        w[i] += 0.5f0 * dt * az[i]
    end
    
    return nothing
end


"""
    kinetic_energy(m, u, v, w)

Compute total kinetic energy of the system.

KE = Σ(½ × m × v²) for all particles

# Arguments
- `m`: Particle mass vector
- `u, v, w`: Particle velocity component vectors

# Returns
- Total kinetic energy as Float64
"""
@fastmath function kinetic_energy(m::AbstractVector{Float32}, u::AbstractVector{Float32}, v::AbstractVector{Float32}, w::AbstractVector{Float32})
    ke = 0.0
    @inbounds @simd for i in eachindex(m)
        # Velocity squared for particle i
        s = float(u[i])*float(u[i]) + float(v[i])*float(v[i]) + float(w[i])*float(w[i])
        ke += 0.5 * float(m[i]) * s
    end
    ke
end


"""
    potential_energy(x, y, z, m, G, eps)

Compute total gravitational potential energy of the system.

PE = -G × Σ(mᵢ × mⱼ / rᵢⱼ) for all particle pairs

# Arguments
- `x, y, z`: Particle position vectors
- `m`: Particle mass vector
- `G`: Gravitational constant
- `eps`: Softening parameter

# Returns
- Total potential energy as Float64
"""
@fastmath function potential_energy(x::AbstractVector{Float32}, y::AbstractVector{Float32}, z::AbstractVector{Float32},
                                   m::AbstractVector{Float32}, G::Float32, eps::Float32)
    N = length(x); pe = 0.0
    eps2 = float(eps*eps)
    
    # Sum over all particle pairs (i < j to avoid double counting)
    @inbounds for i in 1:N-1
        xi = float(x[i]); yi = float(y[i]); zi = float(z[i]); mi = float(m[i])
        
        @simd for j in i+1:N
            # Distance between particles i and j
            dx = float(x[j]) - xi; dy = float(y[j]) - yi; dz = float(z[j]) - zi
            r = sqrt(dx*dx + dy*dy + dz*dz + eps2)
            
            # Gravitational potential energy between this pair
            pe += -float(G) * mi * float(m[j]) / r
        end
    end
    pe
end

# =============================================================================
# INITIAL CONDITION GENERATORS
# =============================================================================

"""
    disk(N, mass_total; Rmax=1.2f0, z_thick=0.1f0, v_rot=0.9f0, jitter=0.05f0, rng=nothing)

Generate initial conditions for a rotating stellar disk.

Creates a 2D disk with small thickness in the z-direction.
Particles are distributed with circular velocities for orbital stability.

# Arguments
- `N`: Number of particles
- `mass_total`: Total mass of the disk
- `Rmax`: Maximum radius of the disk
- `z_thick`: Thickness of the disk in z-direction
- `v_rot`: Rotation velocity scaling factor
- `jitter`: Random velocity perturbation magnitude
- `rng`: Random number generator

# Returns
- `x, y, z, u, v, w, m`: Particle positions, velocities, and masses
"""
function disk(N::Int, mass_total; Rmax=1.2f0, z_thick=0.1f0, v_rot=0.9f0, jitter=0.05f0, rng=nothing)
    # Use seeded RNG if none provided
    if rng === nothing
        rng = MersenneTwister(SEED)
    end
    
    # Generate radial positions (more particles near center)
    R = Rmax .* sqrt.(rand(rng, Float32, N))
    
    # Generate random azimuthal angles
    θ = 2f0*Float32(pi) .* rand(rng, Float32, N)
    
    # Convert to Cartesian coordinates
    x = R .* cos.(θ);  y = R .* sin.(θ);  z = (z_thick*0.5f0) .* randn(rng, Float32, N)
    
    # Circular velocity for orbital stability
    # v = v_rot × R / (0.3 + R) gives a realistic rotation curve
    vtan = v_rot .* R ./ (0.3f0 .+ R)
    u = -vtan .* sin.(θ);  v = vtan .* cos.(θ);  w = zeros(Float32, N)
    
    # Add random velocity perturbations for realistic dynamics
    u .+= jitter .* randn(rng, Float32, N)
    v .+= jitter .* randn(rng, Float32, N)
    w .+= 0.5f0*jitter .* randn(rng, Float32, N)
    
    # Equal mass particles
    m = fill(Float32(mass_total/N), N)
    return x,y,z,u,v,w,m
end

"""
    spiral_disk(N, mass_total; Rd=0.6f0, Rmax=1.8f0, m=2, pitch_deg=18f0, arm_amp=0.65f0, z_thick=0.08f0, v0=1.0f0, v_rise=0.35f0, nudge_r=0.05f0, nudge_t=0.02f0, jitter=0.03f0, rng=nothing, φ0::Union{Nothing,Float32}=nothing)

Generate initial conditions for a spiral galaxy disk.

Creates an exponential disk with logarithmic spiral arm overdensities.
This produces more realistic galaxy morphologies than simple disks.

# Arguments
- `N`: Number of particles
- `mass_total`: Total mass of the disk
- `Rd`: Disk scale length (exponential falloff)
- `Rmax`: Maximum disk radius
- `m`: Number of spiral arms
- `pitch_deg`: Pitch angle of spiral arms in degrees
- `arm_amp`: Amplitude of spiral arm overdensity
- `z_thick`: Disk thickness
- `v0`: Circular velocity at large radius
- `v_rise`: Radius where velocity reaches v0
- `nudge_r, nudge_t`: Radial and tangential velocity perturbations for spiral structure
- `jitter`: Random velocity perturbation
- `rng`: Random number generator
- `φ0`: Initial phase angle for spiral arms

# Returns
- `x, y, z, u, v, w, m`: Particle positions, velocities, and masses
"""
function spiral_disk(N::Int, mass_total; Rd=0.6f0, Rmax=1.8f0, m=2, pitch_deg=18f0,
                     arm_amp=0.65f0, z_thick=0.08f0, v0=1.0f0, v_rise=0.35f0,
                     nudge_r=0.05f0, nudge_t=0.02f0, jitter=0.03f0,
                     rng=nothing, φ0::Union{Nothing,Float32}=nothing)
    # Use seeded RNG if none provided
    if rng === nothing
        rng = MersenneTwister(SEED)
    end
    
    # Set initial phase if not provided
    φ0 === nothing && (φ0 = rand(rng, Float32) * 2f0*pi)

    # Generate radial positions using gamma distribution (more realistic than uniform)
    # Gamma(k=2, θ=Rd) truncated at Rmax
    R = rand(rng, Gamma(2.0, Rd), N) .|> Float32
    
    # Ensure all particles are within Rmax
    while true
        mask = R .> Rmax
        any(mask) || break
        R[mask] .= rand(rng, Gamma(2.0, Rd), count(mask)) .|> Float32
    end

    # Spiral arm parameters
    k = 1f0 / tan(deg2rad(pitch_deg))  # Spiral pitch parameter
    
    # Generate azimuthal angles with spiral arm overdensity
    θ = similar(R)
    filled = 0
    
    # Use rejection sampling to create spiral arm structure
    @inbounds while filled < N
        need = N - filled
        th_try = rand(rng, Float32, need*2) .* (2f0*pi)
        Rrep   = repeat(view(R, filled+1:filled+need), inner=2)
        
        # Probability density for spiral arms
        p = 1 .+ arm_amp .* cos.(Float32(m) .* (th_try .- k .* log.(Rrep .+ 1f-6) .- φ0))
        uacc = rand(rng, Float32, length(th_try)) .* (1 + arm_amp)
        
        # Accept particles based on spiral arm probability
        keep = uacc .< p
        nkeep = min(need, count(keep))
        θ[filled+1:filled+nkeep] .= view(th_try, findall(keep))[1:nkeep]
        filled += nkeep
    end

    # Convert to Cartesian coordinates
    x = R .* cos.(θ);  y = R .* sin.(θ);  z = (z_thick*0.5f0) .* randn(rng, Float32, N)
    
    # Velocity field with spiral structure
    v_circ = v0 .* tanh.(R ./ v_rise)  # Circular velocity
    phase = Float32(m) .* (θ .- k .* log.(R .+ 1f-6) .- φ0)  # Spiral phase
    
    # Velocity perturbations aligned with spiral arms
    v_r = nudge_r .* v_circ .* cos.(phase)  # Radial velocity
    v_t = v_circ .* (1 .+ nudge_t .* sin.(phase))  # Tangential velocity

    # Convert to Cartesian velocity components
    u = -v_t .* sin.(θ) .+ v_r .* cos.(θ)
    v =  v_t .* cos.(θ) .+ v_r .* sin.(θ)
    w =  0.5f0*jitter .* randn(rng, Float32, N)
    
    # Add random perturbations
    u .+= jitter .* randn(rng, Float32, N)
    v .+= jitter .* randn(rng, Float32, N)
    
    # Equal mass particles
    m = fill(Float32(mass_total/N), N)
    return x,y,z,u,v,w,m
end

"""
    init_ic(N, seed, scenario)

Generate initial conditions for the N-body simulation.

Creates different particle distributions based on the selected scenario.
All scenarios are set up in the center-of-mass frame for numerical stability.

# Arguments
- `N`: Number of particles
- `seed`: Random seed for reproducible results
- `scenario`: Initial condition type: "galaxy_spiral", "galaxy", "plummer", or "random"

# Returns
- `x, y, z, u, v, w, m`: Initial particle positions, velocities, and masses
"""
function init_ic(N::Int, seed::Int, scenario::AbstractString)
    rng = MersenneTwister(seed)

    if scenario == "galaxy_spiral"
        # Two spiral galaxies on collision course
        N1 = N ÷ 2; N2 = N - N1
        
        # Different initial phases for the two galaxies
        φ1 = rand(rng, Float32) * 2f0*pi
        φ2 = φ1 + Float32(pi)/3f0

        # Generate first spiral galaxy
        x1,y1,z1,u1,v1,w1,m1 = spiral_disk(N1, 10f0; Rd=0.55f0, Rmax=1.7f0, m=2,
            pitch_deg=18f0, arm_amp=0.70f0, z_thick=0.07f0, v0=1.05f0, v_rise=0.32f0,
            nudge_r=0.06f0, nudge_t=0.03f0, jitter=0.025f0, rng=rng, φ0=φ1)
        
        # Generate second spiral galaxy
        x2,y2,z2,u2,v2,w2,m2 = spiral_disk(N2, 10f0; Rd=0.55f0, Rmax=1.7f0, m=2,
            pitch_deg=18f0, arm_amp=0.70f0, z_thick=0.07f0, v0=1.05f0, v_rise=0.32f0,
            nudge_r=0.06f0, nudge_t=0.03f0, jitter=0.025f0, rng=rng, φ0=φ2)

        # Reverse velocity of second galaxy and offset positions
        u2 .*= -1; v2 .*= -1  # Counter-rotating
        d = 2.1f0; vcm = 0.45f0  # Initial separation and center-of-mass velocity
        
        # Position and velocity offsets for collision
        x1 .+= -d; v1 .+=  vcm
        x2 .+=  d; v2 .+= -vcm

        # Combine the two galaxies
        x = vcat(x1,x2); y = vcat(y1,y2); z = vcat(z1,z2)
        u = vcat(u1,u2); v = vcat(v1,v2); w = vcat(w1,w2)
        m = vcat(m1,m2)

    elseif scenario == "galaxy"
        # Two simple disk galaxies on collision course
        N1 = N ÷ 2; N2 = N - N1
        
        # Generate two identical disk galaxies
        x1,y1,z1,u1,v1,w1,m1 = disk(N1, 10f0; Rmax=1.1f0, z_thick=0.08f0, v_rot=1.0f0, jitter=0.05f0, rng=rng)
        x2,y2,z2,u2,v2,w2,m2 = disk(N2, 10f0; Rmax=1.1f0, z_thick=0.08f0, v_rot=1.0f0, jitter=0.05f0, rng=rng)
        
        # Counter-rotating galaxies
        u2 .*= -1; v2 .*= -1
        d=2.0f0; vcm=0.5f0  # Initial separation and center-of-mass velocity
        
        # Position and velocity offsets
        x1 .+= -d; v1 .+=  vcm
        x2 .+=  d; v2 .+= -vcm
        
        # Combine the galaxies
        x = vcat(x1,x2); y = vcat(y1,y2); z = vcat(z1,z2)
        u = vcat(u1,u2); v = vcat(v1,v2); w = vcat(w1,w2)
        m = vcat(m1,m2)

    elseif scenario == "plummer"
        # Plummer sphere: a realistic model for globular clusters
        a = 0.5f0  # Scale radius
        
        # Generate positions using Plummer distribution
        uU = rand(rng, Float32, N)
        r  = a ./ sqrt.(uU.^(-2f0/3f0) .- 1f0 .+ 1f-6)  # Radial distribution
        
        # Random spherical angles
        ϕ   = 2f0*pi .* rand(rng, Float32, N)      # Azimuthal
        cosθ = 2f0 .* rand(rng, Float32, N) .- 1f0  # Cosine of polar
        sinθ = sqrt.(1f0 .- cosθ.^2)                # Sine of polar
        
        # Convert to Cartesian coordinates
        x = r .* sinθ .* cos.(ϕ); y = r .* sinθ .* sin.(ϕ); z = r .* cosθ
        
        # Small random velocities
        u = 0.02f0 .* randn(rng, Float32, N)
        v = 0.02f0 .* randn(rng, Float32, N)
        w = 0.02f0 .* randn(rng, Float32, N)
        m = fill(20f0/N, N)

    else # "random"
        # Random particle distribution (useful for testing)
        x = randn(rng, Float32, N); y = randn(rng, Float32, N); z = randn(rng, Float32, N)
        u = randn(rng, Float32, N); v = randn(rng, Float32, N); w = randn(rng, Float32, N)
        m = fill(20f0/N, N)
    end

    # Transform to center-of-mass frame for numerical stability
    # This prevents the entire system from drifting
    μu = mean(m .* u); μv = mean(m .* v); μw = mean(m .* w); m̄ = mean(m)
    u .-= μu/m̄; v .-= μv/m̄; w .-= μw/m̄

    return x,y,z,u,v,w,m
end

# =============================================================================
# VISUALIZATION FUNCTIONS
# =============================================================================

"""
    render_snapshot(path::AbstractString, x::AbstractVector{<:Real}, y::AbstractVector{<:Real},
                    z::AbstractVector{<:Real}, u::AbstractVector{<:Real},
                    v::AbstractVector{<:Real}, w::AbstractVector{<:Real},
                    title_str::AbstractString, times::Union{Nothing,AbstractVector{<:Real}}=nothing,
                    KE_save::Union{Nothing,AbstractVector{<:Real}}=nothing,
                    PE_save::Union{Nothing,AbstractVector{<:Real}}=nothing)

Save a snapshot matching the live visualization layout.

Creates a standalone figure with the same layout as the live visualization:
- Top panel: Particle positions with dark theme
- Bottom panel: Energy evolution with light theme (when energy data provided)

# Arguments
- `path`: File path for saving the image
- `x, y, z, u, v, w`: Particle positions and velocities
- `title_str`: Title for the plot
- `times`: Time points for energy history (optional)
- `KE_save`: Kinetic energy history (optional)
- `PE_save`: Potential energy history (optional)
"""
function render_snapshot(path::AbstractString,
                         x::AbstractVector{<:Real}, y::AbstractVector{<:Real},
                         z::AbstractVector{<:Real}, u::AbstractVector{<:Real},
                         v::AbstractVector{<:Real}, w::AbstractVector{<:Real},
                         title_str::AbstractString, times::Union{Nothing,AbstractVector{<:Real}}=nothing,
                         KE_save::Union{Nothing,AbstractVector{<:Real}}=nothing,
                         PE_save::Union{Nothing,AbstractVector{<:Real}}=nothing)
    
    if times !== nothing && KE_save !== nothing && PE_save !== nothing
        # Two-panel layout matching live visualization
        fig = Figure(size = (680, 820))
        grid = fig[1,1] = GridLayout()
        
        # Upper 2 panels merged for positions (dark theme)
        ax_pos = Axis(grid[1:2,1];
            backgroundcolor = :black,
            xticklabelcolor = :white, yticklabelcolor = :white,
            xlabelcolor = :white, ylabelcolor = :white,
            titlecolor = :white, xtickcolor=:white, ytickcolor=:white)
        
        # Color particles by speed
        speed = sqrt.((u.^2) .+ (v.^2) .+ (w.^2))
        smin = quantile(speed, 0.05); smax = max(quantile(speed, 0.95), smin + 1f-6)

        # Apply depth cueing if enabled
        sizes = fill(POINT_SIZE, length(x))
        if DEPTH_CUE
            zmin = quantile(z, 0.05); zmax = quantile(z, 0.95); zrange = max(zmax - zmin, 1f-3)
            depth = clamp.((z .- zmin) ./ zrange, 0f0, 1f0)
            sizes = POINT_SIZE .* (0.6 .+ 0.8 .* (1f0 .- depth))  # Nearer = bigger
        end

        # Plot particles
        scatter!(ax_pos, x, y; color=speed, colormap=CMAP, colorrange=(smin,smax),
                 markersize=sizes, transparency=true)
        xlims!(ax_pos, -BOUNDS, BOUNDS); ylims!(ax_pos, -BOUNDS, BOUNDS)
        ax_pos.aspect = DataAspect()
        ax_pos.title = title_str
        
        # Bottom panel for energies (light theme)
        ax_eng = Axis(grid[3,1])
        
        # Plot energy evolution
        lines!(ax_eng, times, KE_save; color = (0.98, 0.42, 0.42), linewidth = 1.2, label="KE")
        lines!(ax_eng, times, PE_save; color = (0.30, 0.64, 1.00), linewidth = 1.2, label="PE")
        lines!(ax_eng, times, (KE_save .+ PE_save); color = (0.15, 0.15, 0.15), linewidth = 1.3, label="Etot")
        
        # Configure energy panel
        xlims!(ax_eng, 0, maximum(times)); ax_eng.xlabel = "Time [-]"; ax_eng.ylabel = "Energy [-]"
        axislegend(ax_eng, position=:rt, framevisible=true)
    else
        # Single panel for initial snapshot (no energy data yet)
        fig = Figure(size = (720, 720))
        ax  = Axis(fig[1,1];
            backgroundcolor = :black,
            xticklabelcolor = :white, yticklabelcolor = :white,
            xlabelcolor = :white, ylabelcolor = :white,
            titlecolor = :white, xtickcolor=:white, ytickcolor=:white)
        
        # Color particles by speed
        speed = sqrt.((u.^2) .+ (v.^2) .+ (w.^2))
        smin = quantile(speed, 0.05); smax = max(quantile(speed, 0.95), smin + 1f-6)

        # Apply depth cueing if enabled
        sizes = fill(POINT_SIZE, length(x))
        if DEPTH_CUE
            zmin = quantile(z, 0.05); zmax = quantile(z, 0.95); zrange = max(zmax - zmin, 1f-3)
            depth = clamp.((z .- zmin) ./ zrange, 0f0, 1f0)
            sizes = POINT_SIZE .* (0.6 .+ 0.8 .* (1f0 .- depth))  # Nearer = bigger
        end

        # Plot particles
        scatter!(ax, x, y; color=speed, colormap=CMAP, colorrange=(smin,smax),
                 markersize=sizes, transparency=true)
        xlims!(ax, -BOUNDS, BOUNDS); ylims!(ax, -BOUNDS, BOUNDS)
        ax.aspect = DataAspect()
        ax.title = title_str
    end
    
    # Save and close
    save(path, fig)
end

"""
    setup_figure()

Create and configure the main visualization figure.

Sets up a 3-panel layout: positions (top 2/3) and energy (bottom 1/3).
The positions panel uses a dark theme, while the energy panel uses light theme.

# Returns
- `fig`: The main figure
- `ax_pos`: Axes for particle positions (dark theme)
- `ax_eng`: Axes for energy plots (light theme)
"""
function setup_figure()
    fig = Figure(size = (680, 820))
    grid = fig[1,1] = GridLayout()
    
    # Dark theme for positions panel
    ax_pos = Axis(grid[1:2,1];
        backgroundcolor = :black,
        xticklabelcolor = :white, yticklabelcolor = :white,
        xlabelcolor = :white, ylabelcolor = :white,
        titlecolor = :white, xtickcolor=:white, ytickcolor=:white)
    
    # Light theme for energy panel
    ax_eng = Axis(grid[3,1])
    
    return fig, ax_pos, ax_eng
end

# =============================================================================
# MAIN SIMULATION FUNCTION
# =============================================================================

"""
    main()

Main simulation function (optimized version).

Implements the leapfrog integration scheme using optimized kernels:
1. Preallocates acceleration arrays to avoid per-step allocations
2. Uses fused step function to reduce dispatch overhead
3. Includes kernel warm-up to exclude compilation time from timing
4. Maintains fair comparison with other language implementations

This scheme conserves energy better than simple Euler integration.
The function handles both headless runs and real-time visualization.
"""
function main()
    # Display simulation configuration
    @info "Threads = $(Threads.nthreads())  | VISUALIZE=$(VISUALIZE)  | SYM=$(USE_SYM)  | BLOCKED=$(USE_BLOCKED)"

    # Initialize particle system
    if IMPORT_IC !== nothing
        # Import initial conditions from file
        println("Importing initial conditions from: $IMPORT_IC")
        try
            x, y, z, u, v, w, m, file_G, file_softening = import_initial_conditions(IMPORT_IC)
            
            # Use parameters from the imported file
            G_actual = file_G
            softening_actual = file_softening
            N_actual = length(x)
            
            println("Using imported parameters: G=$G_actual, softening=$softening_actual, N=$N_actual")
            
            # Use imported N for the simulation
            if N_actual != N
                println("Warning: Imported N=$N_actual differs from configured N=$N")
                println("Using imported value: N=$N_actual")
            end
            
        catch e
            println("Error importing initial conditions: $e")
            println("Falling back to generated initial conditions...")
            x,y,z,u,v,w,m = init_ic(N, SEED, SCENARIO)
            G_actual = Gconst
            softening_actual = softening
            N_actual = N
        end
    else
        # Generate initial conditions using current method
        println("Initializing $(SCENARIO) scenario with $(N) particles...")
        x,y,z,u,v,w,m = init_ic(N, SEED, SCENARIO)
        G_actual = Gconst
        softening_actual = softening
        N_actual = N
    end
    
    # Allocate acceleration arrays
    ax = zeros(Float32, N_actual); ay = similar(ax); az = similar(ax)
    
    # KERNEL WARM-UP: Run one step with small arrays to compile kernels
    # This ensures compilation time is not included in performance measurements
    println("Warming up JIT kernels...")
    N_warmup = min(100, N)  # Use small arrays for warm-up
    x_warm = view(x, 1:N_warmup)
    y_warm = view(y, 1:N_warmup)
    z_warm = view(z, 1:N_warmup)
    u_warm = view(u, 1:N_warmup)
    v_warm = view(v, 1:N_warmup)
    w_warm = view(w, 1:N_warmup)
    m_warm = view(m, 1:N_warmup)
    ax_warm = zeros(Float32, N_warmup)
    ay_warm = zeros(Float32, N_warmup)
    az_warm = zeros(Float32, N_warmup)
    
    # Warm up the force computation kernels
    if USE_SYM
        if USE_BLOCKED
            compute_acc_sym_blocked!(ax_warm, ay_warm, az_warm, x_warm, y_warm, z_warm, m_warm, G_actual, softening_actual; B=BLOCK_SIZE)
        else
            compute_acc_sym!(ax_warm, ay_warm, az_warm, x_warm, y_warm, z_warm, m_warm, G_actual, softening_actual)
        end
    else
        compute_acc_full!(ax_warm, ay_warm, az_warm, x_warm, y_warm, z_warm, m_warm, G_actual, softening_actual)
    end
    
    # Warm up the step function
    step!(x_warm, y_warm, z_warm, u_warm, v_warm, w_warm, m_warm, 
          ax_warm, ay_warm, az_warm, dt, G_actual, softening_actual, USE_SYM, USE_BLOCKED, BLOCK_SIZE)
    
    println("Kernel warm-up complete!")
    
    # Compute initial accelerations using optimized kernels
    println("Computing initial forces...")
    if USE_SYM
        if USE_BLOCKED
            compute_acc_sym_blocked!(ax, ay, az, x, y, z, m, G_actual, softening_actual; B=BLOCK_SIZE)
        else
            compute_acc_sym!(ax, ay, az, x, y, z, m, G_actual, softening_actual)
        end
    else
        compute_acc_full!(ax, ay, az, x, y, z, m, G_actual, softening_actual)
    end

    # Save initial snapshot if requested
    if STOREFINAL
        println("Saving initial snapshot...")
        render_snapshot("julia/nbody_$(SCENARIO)_initial_julia.png", x,y,z,u,v,w,
            "$(uppercasefirst(replace(SCENARIO, "_" => " "))) – initial")
    end

    # Time integration setup
    Nt = Int(ceil((tEnd)/dt))
    println("Running simulation for $(Nt) time steps (dt=$(dt), tEnd=$(tEnd))...")

    # ----- Real-time visualization setup -----
    if VISUALIZE
        println("Setting up visualization...")
        fig, ax_pos, ax_eng = setup_figure()

        # Observables for current positions & styling
        xobs   = Observable(copy(x))
        yobs   = Observable(copy(y))
        sizeo  = Observable(fill(POINT_SIZE, N))
        coloro = Observable(copy(sqrt.(u.^2 .+ v.^2 .+ w.^2)))
        crange = Observable((0f0, 1f0))

        # Main particle scatter plot
        scatter!(ax_pos, xobs, yobs;
                 color = coloro, colormap = CMAP, colorrange = crange,
                 markersize = sizeo, transparency = true)

        # Configure positions panel
        xlims!(ax_pos, -BOUNDS, BOUNDS); ylims!(ax_pos, -BOUNDS, BOUNDS)
        ax_pos.aspect = DataAspect()
        ax_pos.title = "$(uppercasefirst(replace(SCENARIO, "_" => " ")))  (N=$(N))   t = 0.00"

        # Setup particle trails (optional)
        trail_xobs = Vector{Observable{Vector{Float32}}}()
        trail_yobs = Vector{Observable{Vector{Float32}}}()
        if TRAIL > 0
            resize!(trail_xobs, TRAIL); resize!(trail_yobs, TRAIL)
            
            # Trail appearance parameters
            alphas = TRAIL == 1 ? [0.25]              :
                     collect(range(0.08, 0.35; length = TRAIL))
            sizes_trail = TRAIL == 1 ? [0.7*POINT_SIZE] :
                          collect(range(0.5*POINT_SIZE, 0.9*POINT_SIZE; length = TRAIL))
            
            # Create trail observables
            for k in 1:TRAIL
                trail_xobs[k] = Observable(fill(NaN32, N))
                trail_yobs[k] = Observable(fill(NaN32, N))
                scatter!(ax_pos, trail_xobs[k], trail_yobs[k];
                         color = (0.7,0.7,1.0, alphas[k]),
                         markersize = sizes_trail[k], strokewidth = 0)
            end
        end
        trail_idx = 1

        # Energy tracking observables
        tobs  = Observable(Float32[0.0])
        KE0 = Float32(kinetic_energy(m, u, v, w))
        PE0 = Float32(potential_energy(x, y, z, m, Gconst, softening))
        KEobs = Observable(Float32[KE0])
        PEobs = Observable(Float32[PE0])
        ETobs = Observable(Float32[KE0 + PE0])

        # Energy plots
        lines!(ax_eng, tobs, KEobs; color = (0.98, 0.42, 0.42), linewidth = 1.2, label="KE")
        lines!(ax_eng, tobs, PEobs; color = (0.30, 0.64, 1.00), linewidth = 1.2, label="PE")
        lines!(ax_eng, tobs, ETobs; color = (0.15, 0.15, 0.15), linewidth = 1.3, label="Etot")
        
        # Configure energy panel
        xlims!(ax_eng, 0, tEnd); ax_eng.xlabel = "time"; ax_eng.ylabel = "energy"
        axislegend(ax_eng, position=:rt, framevisible=true)
        
        # Display the figure
        display(fig)
    end

    # ----- Main time integration loop using optimized kernels -----
    t = 0f0
    for it in 1:Nt
        # Use the fused step function for optimal performance
        # This reduces dispatch overhead and improves performance
        step!(x, y, z, u, v, w, m, ax, ay, az, dt, Gconst, softening, USE_SYM, USE_BLOCKED, BLOCK_SIZE)
        t += dt

        # Real-time visualization updates
        if VISUALIZE
            # Track energy conservation
            KE = Float32(kinetic_energy(m,u,v,w))
            PE = Float32(potential_energy(x,y,z,m,Gconst,softening))
            KEobs[] = vcat(KEobs[], KE)
            PEobs[] = vcat(PEobs[], PE)
            ETobs[] = vcat(ETobs[], KE + PE)
            tobs[]  = vcat(tobs[],  Float32(t))

            # Update particle trails (ring buffer)
            if TRAIL > 0
                trail_xobs[trail_idx][] = copy(x)
                trail_yobs[trail_idx][] = copy(y)
                trail_idx = trail_idx % TRAIL + 1
            end

            # Update speed-based coloring
            speed = sqrt.(u.^2 .+ v.^2 .+ w.^2)
            smin = quantile(speed, 0.05); smax = max(quantile(speed, 0.95), smin+1f-6)
            coloro[] = speed
            crange[] = (smin, smax)

            # Apply depth cueing
            if DEPTH_CUE
                zmin = quantile(z, 0.05); zmax = quantile(z, 0.95); zrange = max(zmax - zmin, 1f-3)
                depth = clamp.((z .- zmin) ./ zrange, 0f0, 1f0)
                sizeo[] = POINT_SIZE .* (0.6 .+ 0.8 .* (1f0 .- depth))  # Nearer = bigger
            else
                sizeo[] = fill(POINT_SIZE, N)
            end

            # Update positions and title
            xobs[] = copy(x); yobs[] = copy(y)
            ax_pos.title = "$(uppercasefirst(replace(SCENARIO, "_" => " ")))  (N=$(N))   t = $(round(t; digits=2))"
            
            # Control visualization speed
            sleep(0.001)
        end
    end

    # Save final snapshot if requested
    if STOREFINAL
        println("Saving final snapshot...")
        if VISUALIZE
            # Save the existing live visualization figure (which already has correct styling)
            # This preserves the black background for galaxies panel and white background for energy panel
            save("julia/nbody_$(SCENARIO)_final_julia.png", current_figure())
        else
            # No energy data available when VISUALIZE=false
            # Create a simple snapshot with just particle positions
            render_snapshot("julia/nbody_$(SCENARIO)_final_julia.png", x,y,z,u,v,w,
                "$(uppercasefirst(replace(SCENARIO, "_" => " "))) – final  (t=$(round(t;digits=2)))")
        end
    end

    # Note: Final visualization is already saved above when VISUALIZE=true
    # No need to save the live visualization figure separately
    
    println("Simulation complete!")
end

# =============================================================================
# SCRIPT ENTRY POINT
# =============================================================================

# Run main function if script is executed directly
if isinteractive() || abspath(PROGRAM_FILE) == @__FILE__
    main()
end
